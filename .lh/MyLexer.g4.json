{
    "sourceFile": "MyLexer.g4",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1764231165778,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1764231173339,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,106 @@\n+lexer grammar MyLexer;\n+\n+options { language = Python3; }\n+\n+@lexer::header {\n+KEYWORDS = {\n+    \"ADD\",\"ALL\",\"ALTER\",\"AND\",\"ANY\",\"AS\",\"ASC\",\"BETWEEN\",\"BY\",\"CASE\",\"CHECK\",\n+    \"COLUMN\",\"CONSTRAINT\",\"CREATE\",\"CROSS\",\"DATABASE\",\"DEFAULT\",\"DELETE\",\n+    \"DESC\",\"DISTINCT\",\"DROP\",\"ELSE\",\"END\",\"EXCEPT\",\"EXISTS\",\"FALSE\",\"FETCH\",\n+    \"FOREIGN\",\"FROM\",\"FULL\",\"GROUP\",\"HAVING\",\"ILIKE\",\"IN\",\"INDEX\",\"INNER\",\n+    \"INSERT\",\"INTERSECT\",\"INTO\",\"IS\",\"JOIN\",\"LEFT\",\"LIKE\",\"LIMIT\",\"NATURAL\",\n+    \"NOT\",\"NULL\",\"OFFSET\",\"ON\",\"OR\",\"ORDER\",\"OUTER\",\"OVER\",\"PARTITION\",\n+    \"PRIMARY\",\"RETURNING\",\"RIGHT\",\"ROW\",\"ROWS\",\"SELECT\",\"SET\",\"TABLE\",\n+    \"THEN\",\"TOP\",\"TRUE\",\"UNION\",\"UNIQUE\",\"UNNEST\",\"UPDATE\",\"USING\",\"VALUES\",\n+    \"WHEN\",\"WHERE\",\"WINDOW\",\"WITH\",\"VIEW\",\"TRIGGER\",\"FUNCTION\",\"PROCEDURE\",\"BEGIN\",\"LOOP\",\n+    \"REFERENCES\",\"GRANT\",\"REVOKE\",\"TEMP\",\"TEMPORARY\",\n+    \"REPLACE\",\"MATERIALIZED\",\"ESCAPE\",\"DECLARE\", \"KEY\", \"FIRST\", \"ONLY\",\n+}\n+}\n+\n+@lexer::members {\n+_commentLevel = 0\n+}\n+\n+fragment A : [aA]; \n+fragment B : [bB];\n+fragment C : [cC];\n+fragment D : [dD];\n+fragment E : [eE];\n+fragment F : [fF];\n+fragment G : [gG];\n+fragment H : [hH];\n+fragment I : [iI];\n+fragment J : [jJ];\n+fragment K : [kK];\n+fragment L : [lL];\n+fragment M : [mM];\n+fragment N : [nN];\n+fragment O : [oO];\n+fragment P : [pP];\n+fragment Q : [qQ];\n+fragment R : [rR];\n+fragment S : [sS];\n+fragment T : [tT];\n+fragment U : [uU];\n+fragment V : [vV];\n+fragment W : [wW];\n+fragment X : [xX];\n+fragment Y : [yY];\n+fragment Z : [zZ];\n+\n+fragment KEY : [a-zA-Z_][a-zA-Z0-9_]*;\n+fragment DIGITS : [0-9]+;\n+fragment EXP : [eE] [+-]? DIGITS;\n+LINE_COMMENT : '--' ~[\\r\\n]* -> skip ;\n+\n+BLOCK_COMMENT_START\n+    : '/*' { self._commentLevel = 1; } -> pushMode(COMMENT_MODE)\n+    ;\n+\n+WS : [ \\t\\r\\n]+ -> skip ;\n+STRING\n+    :  '\\'' ( '\\'\\'' | '\\\\' . | ~['\\\\\\r\\n] )* '\\''\n+    |  '0' X ([0-9a-fA-F] | '\\\\' [ \\t]* [\\r\\n])+  \n+    |  '0' B ([01] | '\\\\' [ \\t]* [\\r\\n])+\n+    ;\n+\n+VARIABLE\n+    :  '@@' KEY\n+    |  '@' KEY\n+    ;\n+\n+IDENTIFIER\n+    : KEY\n+      {\n+if self.text.upper() in KEYWORDS:\n+    self.type = MyLexer.KEYWORD\n+      }\n+    ;\n+\n+KEYWORD : ; \n+\n+NUMBER\n+    : DIGITS ('.' DIGITS)? (EXP)?\n+    | '.' DIGITS (EXP)?\n+    ;\n+\n+OPERATOR\n+    : '+' | '-' | '*' | '/' | '%'\n+    | '=' | '<>' | '!=' | '<' | '>' | '<=' | '>='\n+    | '+=' | '-=' | '*=' | '/='\n+    | '&' | '|' | '^' | '~' | '<<' | '>>'\n+    | '.' | ';' | ',' | '(' | ')'\n+    ;\n+\n+mode COMMENT_MODE;\n+\n+COMMENT_MODE_RULE\n+    : '/*' { self._commentLevel += 1; }\n+    | '*/' {\n+        self._commentLevel -= 1;\n+        if self._commentLevel == 0:\n+            self.popMode()\n+      }\n+    | .\n+    ;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1764231247855,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,10 +51,11 @@\n \n fragment KEY : [a-zA-Z_][a-zA-Z0-9_]*;\n fragment DIGITS : [0-9]+;\n fragment EXP : [eE] [+-]? DIGITS;\n-LINE_COMMENT : '--' ~[\\r\\n]* -> skip ;\n \n+LINE_COMMENT : '--' ~[\\r\\n]* ;\n+\n BLOCK_COMMENT_START\n     : '/*' { self._commentLevel = 1; } -> pushMode(COMMENT_MODE)\n     ;\n \n@@ -102,106 +103,5 @@\n         if self._commentLevel == 0:\n             self.popMode()\n       }\n     | .\n-    ;\n-lexer grammar MyLexer;\n-\n-options { language = Python3; }\n-\n-@lexer::header {\n-KEYWORDS = {\n-    \"ADD\",\"ALL\",\"ALTER\",\"AND\",\"ANY\",\"AS\",\"ASC\",\"BETWEEN\",\"BY\",\"CASE\",\"CHECK\",\n-    \"COLUMN\",\"CONSTRAINT\",\"CREATE\",\"CROSS\",\"DATABASE\",\"DEFAULT\",\"DELETE\",\n-    \"DESC\",\"DISTINCT\",\"DROP\",\"ELSE\",\"END\",\"EXCEPT\",\"EXISTS\",\"FALSE\",\"FETCH\",\n-    \"FOREIGN\",\"FROM\",\"FULL\",\"GROUP\",\"HAVING\",\"ILIKE\",\"IN\",\"INDEX\",\"INNER\",\n-    \"INSERT\",\"INTERSECT\",\"INTO\",\"IS\",\"JOIN\",\"LEFT\",\"LIKE\",\"LIMIT\",\"NATURAL\",\n-    \"NOT\",\"NULL\",\"OFFSET\",\"ON\",\"OR\",\"ORDER\",\"OUTER\",\"OVER\",\"PARTITION\",\n-    \"PRIMARY\",\"RETURNING\",\"RIGHT\",\"ROW\",\"ROWS\",\"SELECT\",\"SET\",\"TABLE\",\n-    \"THEN\",\"TOP\",\"TRUE\",\"UNION\",\"UNIQUE\",\"UNNEST\",\"UPDATE\",\"USING\",\"VALUES\",\n-    \"WHEN\",\"WHERE\",\"WINDOW\",\"WITH\",\"VIEW\",\"TRIGGER\",\"FUNCTION\",\"PROCEDURE\",\"BEGIN\",\"LOOP\",\n-    \"REFERENCES\",\"GRANT\",\"REVOKE\",\"TEMP\",\"TEMPORARY\",\n-    \"REPLACE\",\"MATERIALIZED\",\"ESCAPE\",\"DECLARE\", \"KEY\", \"FIRST\", \"ONLY\",\n-}\n-}\n-\n-@lexer::members {\n-_commentLevel = 0\n-}\n-\n-fragment A : [aA]; \n-fragment B : [bB];\n-fragment C : [cC];\n-fragment D : [dD];\n-fragment E : [eE];\n-fragment F : [fF];\n-fragment G : [gG];\n-fragment H : [hH];\n-fragment I : [iI];\n-fragment J : [jJ];\n-fragment K : [kK];\n-fragment L : [lL];\n-fragment M : [mM];\n-fragment N : [nN];\n-fragment O : [oO];\n-fragment P : [pP];\n-fragment Q : [qQ];\n-fragment R : [rR];\n-fragment S : [sS];\n-fragment T : [tT];\n-fragment U : [uU];\n-fragment V : [vV];\n-fragment W : [wW];\n-fragment X : [xX];\n-fragment Y : [yY];\n-fragment Z : [zZ];\n-\n-fragment KEY : [a-zA-Z_][a-zA-Z0-9_]*;\n-fragment DIGITS : [0-9]+;\n-fragment EXP : [eE] [+-]? DIGITS;\n-\n-STRING\n-    :  '\\'' ( '\\'\\'' | '\\\\' . | ~['\\\\\\r\\n] )* '\\''\n-    |  '0' X ([0-9a-fA-F] | '\\\\' [ \\t]* [\\r\\n])+  \n-    |  '0' B ([01] | '\\\\' [ \\t]* [\\r\\n])+\n-    ;\n-\n-VARIABLE\n-    :  '@@' KEY\n-    |  '@' KEY\n-    ;\n-\n-IDENTIFIER\n-    : KEY\n-      {\n-if self.text.upper() in KEYWORDS:\n-    self.type = MyLexer.KEYWORD\n-      }\n-    ;\n-\n-KEYWORD : ; \n-\n-NUMBER\n-    : DIGITS ('.' DIGITS)? (EXP)?\n-    | '.' DIGITS (EXP)?\n-    ;\n-\n-OPERATOR\n-    : '+' | '-' | '*' | '/' | '%'\n-    | '=' | '<>' | '!=' | '<' | '>' | '<=' | '>='\n-    | '+=' | '-=' | '*=' | '/='\n-    | '&' | '|' | '^' | '~' | '<<' | '>>'\n-    | '.' | ';' | ',' | '(' | ')'\n-    ;\n-\n-\n-mode COMMENT_MODE;\n-\n-COMMENT_MODE_RULE\n-    : '/*' { self._commentLevel += 1; }\n-    | '*/' {\n-        self._commentLevel -= 1;\n-        if self._commentLevel == 0:\n-            self.popMode()\n-      }\n-    | .\n     ;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1764231278465,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,8 +59,9 @@\n     : '/*' { self._commentLevel = 1; } -> pushMode(COMMENT_MODE)\n     ;\n \n WS : [ \\t\\r\\n]+ -> skip ;\n+\n STRING\n     :  '\\'' ( '\\'\\'' | '\\\\' . | ~['\\\\\\r\\n] )* '\\''\n     |  '0' X ([0-9a-fA-F] | '\\\\' [ \\t]* [\\r\\n])+  \n     |  '0' B ([01] | '\\\\' [ \\t]* [\\r\\n])+\n"
                },
                {
                    "date": 1764231285614,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,108 @@\n+lexer grammar MyLexer;\n+\n+options { language = Python3; }\n+\n+@lexer::header {\n+KEYWORDS = {\n+    \"ADD\",\"ALL\",\"ALTER\",\"AND\",\"ANY\",\"AS\",\"ASC\",\"BETWEEN\",\"BY\",\"CASE\",\"CHECK\",\n+    \"COLUMN\",\"CONSTRAINT\",\"CREATE\",\"CROSS\",\"DATABASE\",\"DEFAULT\",\"DELETE\",\n+    \"DESC\",\"DISTINCT\",\"DROP\",\"ELSE\",\"END\",\"EXCEPT\",\"EXISTS\",\"FALSE\",\"FETCH\",\n+    \"FOREIGN\",\"FROM\",\"FULL\",\"GROUP\",\"HAVING\",\"ILIKE\",\"IN\",\"INDEX\",\"INNER\",\n+    \"INSERT\",\"INTERSECT\",\"INTO\",\"IS\",\"JOIN\",\"LEFT\",\"LIKE\",\"LIMIT\",\"NATURAL\",\n+    \"NOT\",\"NULL\",\"OFFSET\",\"ON\",\"OR\",\"ORDER\",\"OUTER\",\"OVER\",\"PARTITION\",\n+    \"PRIMARY\",\"RETURNING\",\"RIGHT\",\"ROW\",\"ROWS\",\"SELECT\",\"SET\",\"TABLE\",\n+    \"THEN\",\"TOP\",\"TRUE\",\"UNION\",\"UNIQUE\",\"UNNEST\",\"UPDATE\",\"USING\",\"VALUES\",\n+    \"WHEN\",\"WHERE\",\"WINDOW\",\"WITH\",\"VIEW\",\"TRIGGER\",\"FUNCTION\",\"PROCEDURE\",\"BEGIN\",\"LOOP\",\n+    \"REFERENCES\",\"GRANT\",\"REVOKE\",\"TEMP\",\"TEMPORARY\",\n+    \"REPLACE\",\"MATERIALIZED\",\"ESCAPE\",\"DECLARE\", \"KEY\", \"FIRST\", \"ONLY\",\n+}\n+}\n+\n+@lexer::members {\n+_commentLevel = 0\n+}\n+\n+fragment A : [aA]; \n+fragment B : [bB];\n+fragment C : [cC];\n+fragment D : [dD];\n+fragment E : [eE];\n+fragment F : [fF];\n+fragment G : [gG];\n+fragment H : [hH];\n+fragment I : [iI];\n+fragment J : [jJ];\n+fragment K : [kK];\n+fragment L : [lL];\n+fragment M : [mM];\n+fragment N : [nN];\n+fragment O : [oO];\n+fragment P : [pP];\n+fragment Q : [qQ];\n+fragment R : [rR];\n+fragment S : [sS];\n+fragment T : [tT];\n+fragment U : [uU];\n+fragment V : [vV];\n+fragment W : [wW];\n+fragment X : [xX];\n+fragment Y : [yY];\n+fragment Z : [zZ];\n+\n+fragment KEY : [a-zA-Z_][a-zA-Z0-9_]*;\n+fragment DIGITS : [0-9]+;\n+fragment EXP : [eE] [+-]? DIGITS;\n+\n+LINE_COMMENT : '--' ~[\\r\\n]* ;\n+\n+BLOCK_COMMENT_START\n+    : '/*' { self._commentLevel = 1; } -> pushMode(COMMENT_MODE)\n+    ;\n+\n+WS : [ \\t\\r\\n]+ -> skip ;\n+\n+STRING\n+    :  '\\'' ( '\\'\\'' | '\\\\' . | ~['\\\\\\r\\n] )* '\\''\n+    |  '0' X ([0-9a-fA-F] | '\\\\' [ \\t]* [\\r\\n])+  \n+    |  '0' B ([01] | '\\\\' [ \\t]* [\\r\\n])+\n+    ;\n+\n+VARIABLE\n+    :  '@@' KEY\n+    |  '@' KEY\n+    ;\n+\n+IDENTIFIER\n+    : KEY\n+      {\n+if self.text.upper() in KEYWORDS:\n+    self.type = MyLexer.KEYWORD\n+      }\n+    ;\n+\n+KEYWORD : ; \n+\n+NUMBER\n+    : DIGITS ('.' DIGITS)? (EXP)?\n+    | '.' DIGITS (EXP)?\n+    ;\n+\n+OPERATOR\n+    : '+' | '-' | '*' | '/' | '%'\n+    | '=' | '<>' | '!=' | '<' | '>' | '<=' | '>='\n+    | '+=' | '-=' | '*=' | '/='\n+    | '&' | '|' | '^' | '~' | '<<' | '>>'\n+    | '.' | ';' | ',' | '(' | ')'\n+    ;\n+\n+mode COMMENT_MODE;\n+\n+COMMENT_MODE_RULE\n+    : '/*' { self._commentLevel += 1; }\n+    | '*/' {\n+        self._commentLevel -= 1;\n+        if self._commentLevel == 0:\n+            self.popMode()\n+      }\n+    | .\n+    ;\n\\ No newline at end of file\n"
                }
            ],
            "date": 1764231165778,
            "name": "Commit-0",
            "content": "lexer grammar MyLexer;\n\noptions { language = Python3; }\n\n@lexer::header {\nKEYWORDS = {\n    \"ADD\",\"ALL\",\"ALTER\",\"AND\",\"ANY\",\"AS\",\"ASC\",\"BETWEEN\",\"BY\",\"CASE\",\"CHECK\",\n    \"COLUMN\",\"CONSTRAINT\",\"CREATE\",\"CROSS\",\"DATABASE\",\"DEFAULT\",\"DELETE\",\n    \"DESC\",\"DISTINCT\",\"DROP\",\"ELSE\",\"END\",\"EXCEPT\",\"EXISTS\",\"FALSE\",\"FETCH\",\n    \"FOREIGN\",\"FROM\",\"FULL\",\"GROUP\",\"HAVING\",\"ILIKE\",\"IN\",\"INDEX\",\"INNER\",\n    \"INSERT\",\"INTERSECT\",\"INTO\",\"IS\",\"JOIN\",\"LEFT\",\"LIKE\",\"LIMIT\",\"NATURAL\",\n    \"NOT\",\"NULL\",\"OFFSET\",\"ON\",\"OR\",\"ORDER\",\"OUTER\",\"OVER\",\"PARTITION\",\n    \"PRIMARY\",\"RETURNING\",\"RIGHT\",\"ROW\",\"ROWS\",\"SELECT\",\"SET\",\"TABLE\",\n    \"THEN\",\"TOP\",\"TRUE\",\"UNION\",\"UNIQUE\",\"UNNEST\",\"UPDATE\",\"USING\",\"VALUES\",\n    \"WHEN\",\"WHERE\",\"WINDOW\",\"WITH\",\"VIEW\",\"TRIGGER\",\"FUNCTION\",\"PROCEDURE\",\"BEGIN\",\"LOOP\",\n    \"REFERENCES\",\"GRANT\",\"REVOKE\",\"TEMP\",\"TEMPORARY\",\n    \"REPLACE\",\"MATERIALIZED\",\"ESCAPE\",\"DECLARE\", \"KEY\", \"FIRST\", \"ONLY\",\n}\n}\n\n@lexer::members {\n_commentLevel = 0\n}\n\nfragment A : [aA]; \nfragment B : [bB];\nfragment C : [cC];\nfragment D : [dD];\nfragment E : [eE];\nfragment F : [fF];\nfragment G : [gG];\nfragment H : [hH];\nfragment I : [iI];\nfragment J : [jJ];\nfragment K : [kK];\nfragment L : [lL];\nfragment M : [mM];\nfragment N : [nN];\nfragment O : [oO];\nfragment P : [pP];\nfragment Q : [qQ];\nfragment R : [rR];\nfragment S : [sS];\nfragment T : [tT];\nfragment U : [uU];\nfragment V : [vV];\nfragment W : [wW];\nfragment X : [xX];\nfragment Y : [yY];\nfragment Z : [zZ];\n\nfragment KEY : [a-zA-Z_][a-zA-Z0-9_]*;\nfragment DIGITS : [0-9]+;\nfragment EXP : [eE] [+-]? DIGITS;\n\nSTRING\n    :  '\\'' ( '\\'\\'' | '\\\\' . | ~['\\\\\\r\\n] )* '\\''\n    |  '0' X ([0-9a-fA-F] | '\\\\' [ \\t]* [\\r\\n])+  \n    |  '0' B ([01] | '\\\\' [ \\t]* [\\r\\n])+\n    ;\n\nVARIABLE\n    :  '@@' KEY\n    |  '@' KEY\n    ;\n\nIDENTIFIER\n    : KEY\n      {\nif self.text.upper() in KEYWORDS:\n    self.type = MyLexer.KEYWORD\n      }\n    ;\n\nKEYWORD : ; \n\nNUMBER\n    : DIGITS ('.' DIGITS)? (EXP)?\n    | '.' DIGITS (EXP)?\n    ;\n\nOPERATOR\n    : '+' | '-' | '*' | '/' | '%'\n    | '=' | '<>' | '!=' | '<' | '>' | '<=' | '>='\n    | '+=' | '-=' | '*=' | '/='\n    | '&' | '|' | '^' | '~' | '<<' | '>>'\n    | '.' | ';' | ',' | '(' | ')'\n    ;\n\n\nmode COMMENT_MODE;\n\nCOMMENT_MODE_RULE\n    : '/*' { self._commentLevel += 1; }\n    | '*/' {\n        self._commentLevel -= 1;\n        if self._commentLevel == 0:\n            self.popMode()\n      }\n    | .\n    ;"
        }
    ]
}