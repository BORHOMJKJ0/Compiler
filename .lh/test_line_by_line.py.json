{
    "sourceFile": "test_line_by_line.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1768863021412,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1768863021412,
            "name": "Commit-0",
            "content": "\"\"\"\nStatement-Based SQL Parser Test\nØ§Ø®ØªØ¨Ø§Ø± Parser Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ SQL Statements Ø§Ù„ÙƒØ§Ù…Ù„Ø©\n\"\"\"\n\nimport sys\nfrom pathlib import Path\nfrom antlr4 import *\nfrom antlr4.error.ErrorListener import ErrorListener\nfrom datetime import datetime\nimport re\n\n\nclass SQLErrorListener(ErrorListener):\n    \"\"\"Ù…Ø³ØªÙ…Ø¹ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.errors = []\n\n    def syntaxError(self, recognizer, offendingSymbol, line, column, msg, e):\n        self.errors.append({\n            'line': line,\n            'column': column,\n            'message': msg[:200],\n            'symbol': offendingSymbol.text[:50] if offendingSymbol else '<EOF>'\n        })\n\n\nclass StatementBasedTester:\n    \"\"\"Ø§Ø®ØªØ¨Ø§Ø± Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Statements\"\"\"\n\n    def __init__(self):\n        try:\n            from BaseLexer import BaseLexer\n            from SQLParser import SQLParser\n            self.BaseLexer = BaseLexer\n            self.SQLParser = SQLParser\n            print(\"âœ… Successfully loaded BaseLexer and SQLParser\\n\")\n        except ImportError as e:\n            print(f\"âŒ Error importing: {e}\")\n            sys.exit(1)\n\n    def split_into_statements(self, sql_code):\n        \"\"\"ØªÙ‚Ø³ÙŠÙ… SQL Ø¥Ù„Ù‰ statements Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ GO Ùˆ semicolon\"\"\"\n        # Ø§Ø³ØªØ¨Ø¯Ù„ GO Ø¨Ù€ separator\n        sql_code = re.sub(r'\\bGO\\b', '\\n---STATEMENT_SEPARATOR---\\n', sql_code, flags=re.IGNORECASE)\n\n        # Ù‚Ø³Ù‘Ù… Ø¹Ù„Ù‰ separator\n        statements = []\n        current = []\n\n        for line in sql_code.split('\\n'):\n            if line.strip() == '---STATEMENT_SEPARATOR---':\n                if current:\n                    stmt = '\\n'.join(current).strip()\n                    if stmt:\n                        statements.append(stmt)\n                    current = []\n            else:\n                current.append(line)\n\n        # Ø¢Ø®Ø± statement\n        if current:\n            stmt = '\\n'.join(current).strip()\n            if stmt:\n                statements.append(stmt)\n\n        return statements\n\n    def test_statement(self, stmt_num, statement):\n        \"\"\"Ø§Ø®ØªØ¨Ø§Ø± statement ÙˆØ§Ø­Ø¯\"\"\"\n        try:\n            start_time = datetime.now()\n\n            # Lexing\n            input_stream = InputStream(statement)\n            lexer = self.BaseLexer(input_stream)\n            token_stream = CommonTokenStream(lexer)\n            token_stream.fill()\n\n            token_count = len(token_stream.tokens)\n\n            # Parsing\n            parser = self.SQLParser(token_stream)\n            error_listener = SQLErrorListener()\n            parser.removeErrorListeners()\n            parser.addErrorListener(error_listener)\n\n            tree = parser.sqlScript()\n\n            end_time = datetime.now()\n            parsing_time = (end_time - start_time).total_seconds() * 1000\n\n            # Ø§Ù„Ù†ØªØ§Ø¦Ø¬\n            if len(error_listener.errors) == 0:\n                return {\n                    'status': 'SUCCESS',\n                    'time': parsing_time,\n                    'tokens': token_count,\n                    'errors': []\n                }\n            else:\n                return {\n                    'status': 'FAILED',\n                    'time': parsing_time,\n                    'tokens': token_count,\n                    'errors': error_listener.errors\n                }\n\n        except Exception as e:\n            return {\n                'status': 'EXCEPTION',\n                'time': 0,\n                'tokens': 0,\n                'errors': [{'message': str(e)[:200]}]\n            }\n\n    def test_file(self, filepath):\n        \"\"\"Ø§Ø®ØªØ¨Ø§Ø± Ù…Ù„Ù ÙƒØ§Ù…Ù„\"\"\"\n        filepath = Path(filepath)\n\n        print(\"=\" * 100)\n        print(f\"ğŸ“ TESTING FILE: {filepath.name}\")\n        print(\"=\" * 100)\n\n        if not filepath.exists():\n            print(f\"âŒ File not found\")\n            return\n\n        with open(filepath, 'r', encoding='utf-8') as f:\n            sql_code = f.read()\n\n        # ØªÙ‚Ø³ÙŠÙ… Ø¥Ù„Ù‰ statements\n        statements = self.split_into_statements(sql_code)\n\n        print(f\"\\nğŸ“Š File Statistics:\")\n        print(f\"   Total Characters: {len(sql_code)}\")\n        print(f\"   Total Lines: {len(sql_code.split(chr(10)))}\")\n        print(f\"   Total Statements: {len(statements)}\")\n        print()\n\n        # Ø§Ø®ØªØ¨Ø§Ø± ÙƒÙ„ statement\n        print(\"ğŸ” Testing each statement:\")\n        print(\"â”€\" * 100)\n        print(f\"{'#':>3} | {'Status':^10} | {'Time':>8} | {'Tokens':>6} | {'Preview':<60}\")\n        print(\"â”€\" * 100)\n\n        results = []\n\n        for i, stmt in enumerate(statements, 1):\n            # Preview Ù…Ù† Ø£ÙˆÙ„ Ø³Ø·Ø±\n            preview = stmt.split('\\n')[0].strip()[:60]\n            if len(stmt.split('\\n')[0]) > 60:\n                preview += \"...\"\n\n            # Ø§Ø®ØªØ¨Ø§Ø±\n            result = self.test_statement(i, stmt)\n            results.append(result)\n\n            # Ø¹Ø±Ø¶ Ø§Ù„Ù†ØªÙŠØ¬Ø©\n            if result['status'] == 'SUCCESS':\n                icon = 'âœ…'\n                status = 'SUCCESS'\n            elif result['status'] == 'FAILED':\n                icon = 'âŒ'\n                status = 'FAILED'\n            else:\n                icon = 'ğŸ’¥'\n                status = 'EXCEPT'\n\n            print(f\"{i:3d} | {icon} {status:^8} | {result['time']:>7.1f}ms | {result['tokens']:>6d} | {preview}\")\n\n        print(\"â”€\" * 100)\n\n        # Ø¹Ø±Ø¶ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡\n        failed = [r for r in results if r['status'] != 'SUCCESS']\n\n        if failed:\n            print(f\"\\nâŒ FAILED STATEMENTS DETAILS:\")\n            print(\"=\" * 100)\n\n            for i, stmt in enumerate(statements, 1):\n                result = results[i-1]\n                if result['status'] != 'SUCCESS':\n                    print(f\"\\nğŸ“‹ Statement {i}:\")\n                    # Ø¹Ø±Ø¶ Ø£ÙˆÙ„ 5 Ø£Ø³Ø·Ø± Ù…Ù† statement\n                    lines = stmt.split('\\n')[:5]\n                    for line in lines:\n                        print(f\"   {line}\")\n                    num_lines = len(stmt.split('\\n'))\n                    if num_lines > 5:\n                        print(f\"   ... ({num_lines - 5} more lines)\")\n\n                    print(f\"\\n   Errors:\")\n                    for err in result['errors'][:3]:\n                        print(f\"      â””â”€ Line {err.get('line', '?')}: {err['message'][:80]}\")\n\n        # Ø§Ù„Ù…Ù„Ø®Øµ\n        success_count = sum(1 for r in results if r['status'] == 'SUCCESS')\n        failed_count = len(results) - success_count\n\n        print(f\"\\n{'=' * 100}\")\n        print(\"ğŸ“Š SUMMARY\")\n        print(\"=\" * 100)\n        print(f\"\\n   Total Statements:  {len(results):3d}\")\n        print(f\"   âœ… Success:        {success_count:3d} ({success_count/len(results)*100:.1f}%)\")\n        print(f\"   âŒ Failed:         {failed_count:3d} ({failed_count/len(results)*100:.1f}%)\")\n\n        if results:\n            times = [r['time'] for r in results if r['time'] > 0]\n            if times:\n                print(f\"\\n   Performance:\")\n                print(f\"      Average: {sum(times)/len(times):.1f}ms\")\n                print(f\"      Max:     {max(times):.1f}ms\")\n                print(f\"      Min:     {min(times):.1f}ms\")\n\n        print(\"=\" * 100)\n\n        return success_count == len(results)\n\n\ndef main():\n    \"\"\"Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©\"\"\"\n    print(\"=\" * 100)\n    print(\"         STATEMENT-BASED SQL PARSER TEST\")\n    print(\"=\" * 100)\n    print()\n\n    tester = StatementBasedTester()\n\n    # Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù…Ù„ÙØ§Øª\n    files = [\n        ('sqlInput.txt', 'Main test file'),\n        ('testing.sql', 'Testing file'),\n        ('train.sql', 'Training queries'),\n        ('train2.sql', 'Advanced training'),\n        \n    ]\n\n    results = {}\n\n    for filename, description in files:\n        if Path(filename).exists():\n            print(f\"\\nğŸ“ {description}\")\n            success = tester.test_file(filename)\n            results[filename] = success\n        else:\n            print(f\"\\nâš ï¸  Skipping {filename} - not found\")\n\n    # Ù…Ù„Ø®Øµ Ù†Ù‡Ø§Ø¦ÙŠ\n    print(\"\\n\" + \"=\" * 100)\n    print(\"ğŸ FINAL RESULTS\")\n    print(\"=\" * 100)\n\n    for filename, success in results.items():\n        status = \"âœ… PASS\" if success else \"âŒ FAIL\"\n        print(f\"   {status} - {filename}\")\n\n    total_pass = sum(1 for s in results.values() if s)\n    print(f\"\\n   Overall: {total_pass}/{len(results)} files passed\")\n    print(\"=\" * 100)\n\n\nif __name__ == '__main__':\n    main()"
        }
    ]
}