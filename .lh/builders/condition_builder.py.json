{
    "sourceFile": "builders/condition_builder.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1768865211626,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1768865906049,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,10 +22,9 @@\n             return BinaryConditionNode(left=left, operator=operator, right=right)\n \n         elif hasattr(ctx, 'expressionList') and ctx.expressionList():\n             left = expr_builder.build_expression(ctx.expression(0))\n-            expressionList = expr_builder.build_expression_list(\n-                ctx.expressionList())\n+            expressionList = expr_builder.build_expression_list(ctx.expressionList())\n             keywordIn = \"IN\"\n             keywordNot = \"NOT\" if \"NOT\" in ctx.getText().upper() else None\n             return InConditionNode(\n                 left=left,\n@@ -55,9 +54,8 @@\n             return LogicalConditionNode(left=left, operator=operator, right=right)\n \n         # Fallback for EXISTS or other conditions\n         from dataclasses import dataclass\n-\n         @dataclass\n         class GenericConditionNode:\n             type: str\n             text: str\n"
                },
                {
                    "date": 1768866013688,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,8 @@\n class ConditionBuilder:\n     \"\"\"Builder for condition AST nodes\"\"\"\n \n     def build_condition(self, ctx):\n-        \"\"\"Build a condition node from context\"\"\"\n         from builders.expression_builder import ExpressionBuilder\n         from Ast.condition_nodes import BinaryConditionNode, InConditionNode, IsNotConditionNode, ParenthesizedConditionNode, LogicalConditionNode\n         expr_builder = ExpressionBuilder()\n \n"
                },
                {
                    "date": 1768913160460,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,9 +51,8 @@\n             right = self.build_condition(ctx.condition(1))\r\n             operator = \"AND\" if \"AND\" in ctx.getText().upper() else \"OR\"\r\n             return LogicalConditionNode(left=left, operator=operator, right=right)\r\n \r\n-        # Fallback for EXISTS or other conditions\r\n         from dataclasses import dataclass\r\n \r\n         @dataclass\r\n         class GenericConditionNode:\r\n"
                },
                {
                    "date": 1769015940435,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,112 +10,147 @@\n             IsNotConditionNode\r\n         )\r\n         expr_builder = ExpressionBuilder()\r\n \r\n-        # Handle parenthesized conditions\r\n-        if hasattr(ctx, 'LPAREN') and ctx.LPAREN() and hasattr(ctx, 'condition') and ctx.condition():\r\n-            inner_condition = self.build_condition(ctx.condition())\r\n-            return ParenthesizedConditionNode(condition=inner_condition)\r\n+        # The condition is actually just an expression in the grammar\r\n+        # So we need to parse the expression and handle operators within it\r\n+        if hasattr(ctx, 'expression') and ctx.expression():\r\n+            expr_ctx = ctx.expression()\r\n+            \r\n+            # If it's a list, take the first one (shouldn't happen for conditions)\r\n+            if isinstance(expr_ctx, list):\r\n+                expr_ctx = expr_ctx[0] if len(expr_ctx) > 0 else None\r\n+            \r\n+            if expr_ctx:\r\n+                return self._build_expression_as_condition(expr_ctx, expr_builder)\r\n+        \r\n+        # Fallback\r\n+        return expr_builder.build_expression(ctx)\r\n \r\n-        # Try to get all expressions in the condition\r\n-        expressions = None\r\n+    def _build_expression_as_condition(self, expr_ctx, expr_builder):\r\n+        \"\"\"Build an expression that represents a condition with operators\"\"\"\r\n+        from Ast.condition_nodes import BinaryConditionNode, LogicalConditionNode\r\n+        \r\n+        # Get all primary expressions and operators from the expression context\r\n+        primaries = []\r\n+        operators = []\r\n+        \r\n+        # Walk through children to find primaries and operators\r\n+        if hasattr(expr_ctx, 'getChildCount'):\r\n+            for i in range(expr_ctx.getChildCount()):\r\n+                child = expr_ctx.getChild(i)\r\n+                child_text = child.getText() if hasattr(child, 'getText') else str(child)\r\n+                \r\n+                # Check if it's a primary\r\n+                if hasattr(child, 'getRuleIndex'):\r\n+                    rule_name = type(child).__name__\r\n+                    if 'Primary' in rule_name or 'primary' in rule_name:\r\n+                        primaries.append(child)\r\n+                \r\n+                # Check if it's a binaryOp\r\n+                if hasattr(child, 'getRuleIndex'):\r\n+                    rule_name = type(child).__name__\r\n+                    if 'BinaryOp' in rule_name or 'binaryOp' in rule_name:\r\n+                        operators.append(child.getText())\r\n+        \r\n+        # If we found primaries and operators, build the condition tree\r\n+        if len(primaries) > 0 and len(operators) > 0:\r\n+            return self._build_condition_tree(primaries, operators, expr_builder)\r\n+        \r\n+        # Otherwise try the old method\r\n         try:\r\n-            expr_result = ctx.expression()\r\n-            if isinstance(expr_result, list):\r\n-                expressions = expr_result\r\n-            elif expr_result is not None:\r\n-                expressions = [expr_result]\r\n-        except (AttributeError, TypeError):\r\n+            # Try to get primary() method results\r\n+            primary_result = expr_ctx.primary() if hasattr(expr_ctx, 'primary') else None\r\n+            if primary_result:\r\n+                if isinstance(primary_result, list) and len(primary_result) > 0:\r\n+                    primaries = primary_result\r\n+                elif not isinstance(primary_result, list):\r\n+                    primaries = [primary_result]\r\n+            \r\n+            # Try to get binaryOp() method results  \r\n+            binop_result = expr_ctx.binaryOp() if hasattr(expr_ctx, 'binaryOp') else None\r\n+            if binop_result:\r\n+                if isinstance(binop_result, list):\r\n+                    operators = [op.getText() for op in binop_result]\r\n+                else:\r\n+                    operators = [binop_result.getText()]\r\n+            \r\n+            if len(primaries) > 0 and len(operators) > 0:\r\n+                return self._build_condition_tree(primaries, operators, expr_builder)\r\n+        except:\r\n             pass\r\n+        \r\n+        # Final fallback - just build as expression\r\n+        return expr_builder.build_expression(expr_ctx)\r\n \r\n-        # If we have expressions, check for operators\r\n-        if expressions:\r\n-            # Handle logical operators (AND, OR)\r\n-            if hasattr(ctx, 'AND') and ctx.AND():\r\n-                # Build left and right as conditions recursively\r\n-                left_expr = expressions[0] if len(expressions) > 0 else None\r\n-                right_expr = expressions[1] if len(expressions) > 1 else None\r\n+    def _build_condition_tree(self, primaries, operators, expr_builder):\r\n+        \"\"\"Build a tree of conditions from primaries and operators\"\"\"\r\n+        from Ast.condition_nodes import BinaryConditionNode, LogicalConditionNode\r\n+        \r\n+        if len(primaries) == 0:\r\n+            return None\r\n+        \r\n+        if len(primaries) == 1:\r\n+            # Single expression, no operators\r\n+            return expr_builder.build_primary(primaries[0])\r\n+        \r\n+        # We need to build a tree respecting operator precedence\r\n+        # Logical operators (AND, OR) have lower precedence than comparison operators (=, <>, etc.)\r\n+        \r\n+        # First, handle comparison operators to create binary conditions\r\n+        conditions = []\r\n+        i = 0\r\n+        \r\n\\ No newline at end of file\n+        while i < len(primaries):\r\n+            if i < len(operators):\r\n+                op = operators[i].upper()\r\n                 \r\n-                if left_expr and right_expr:\r\n-                    # For logical operators, we need to convert expressions to conditions\r\n-                    left_cond = self._expression_to_condition(left_expr, expr_builder)\r\n-                    right_cond = self._expression_to_condition(right_expr, expr_builder)\r\n-                    return LogicalConditionNode(left=left_cond, operator=\"AND\", right=right_cond)\r\n-            \r\n-            elif hasattr(ctx, 'OR') and ctx.OR():\r\n-                left_expr = expressions[0] if len(expressions) > 0 else None\r\n-                right_expr = expressions[1] if len(expressions) > 1 else None\r\n+                # Check if this is a comparison operator (not AND/OR)\r\n+                if op in ('=', '<>', '!=', '<', '>', '<=', '>=', 'LIKE', 'IN', 'IS'):\r\n+                    # Create a binary condition\r\n+                    if i + 1 < len(primaries):\r\n+                        left_expr = expr_builder.build_primary(primaries[i])\r\n+                        right_expr = expr_builder.build_primary(primaries[i + 1])\r\n+                        condition = BinaryConditionNode(left=left_expr, operator=op, right=right_expr)\r\n+                        conditions.append(condition)\r\n+                        i += 2  # Skip both primaries we just used\r\n+                        continue\r\n                 \r\n-                if left_expr and right_expr:\r\n-                    left_cond = self._expression_to_condition(left_expr, expr_builder)\r\n-                    right_cond = self._expression_to_condition(right_expr, expr_builder)\r\n-                    return LogicalConditionNode(left=left_cond, operator=\"OR\", right=right_cond)\r\n-\r\n-            # Handle comparison operators (=, <>, <, >, <=, >=)\r\n-            elif hasattr(ctx, 'binaryOp') and ctx.binaryOp():\r\n-                if len(expressions) >= 2:\r\n-                    left = expr_builder.build_expression(expressions[0])\r\n-                    right = expr_builder.build_expression(expressions[1])\r\n-                    operator = ctx.binaryOp().getText()\r\n-                    return BinaryConditionNode(left=left, operator=operator, right=right)\r\n+                # If it's AND/OR, we'll handle it later\r\n+                elif op in ('AND', 'OR'):\r\n+                    # Add the current primary as a condition\r\n+                    conditions.append(expr_builder.build_primary(primaries[i]))\r\n+                    i += 1\r\n+                    continue\r\n             \r\n-            elif hasattr(ctx, 'OPERATOR') and ctx.OPERATOR():\r\n-                if len(expressions) >= 2:\r\n-                    left = expr_builder.build_expression(expressions[0])\r\n-                    right = expr_builder.build_expression(expressions[1])\r\n-                    operator = ctx.OPERATOR().getText()\r\n-                    return BinaryConditionNode(left=left, operator=operator, right=right)\r\n-\r\n-            # Handle IN operator\r\n-            elif hasattr(ctx, 'IN') and ctx.IN():\r\n-                if len(expressions) >= 1:\r\n-                    left = expr_builder.build_expression(expressions[0])\r\n-                    # The rest are the values in the IN clause\r\n-                    expression_list = [expr_builder.build_expression(e) for e in expressions[1:]]\r\n-                    keyword_not = \"NOT\" if hasattr(ctx, 'NOT') and ctx.NOT() else None\r\n-                    return InConditionNode(\r\n-                        left=left,\r\n-                        keywordIn=\"IN\",\r\n-                        expressionList=expression_list,\r\n-                        keywordNot=keyword_not\r\n-                    )\r\n-\r\n-            # Handle IS NULL / IS NOT NULL\r\n-            elif hasattr(ctx, 'IS') and ctx.IS():\r\n-                if len(expressions) >= 1:\r\n-                    left = expr_builder.build_expression(expressions[0])\r\n-                    keyword_not = \"NOT\" if hasattr(ctx, 'NOT') and ctx.NOT() else None\r\n-                    if keyword_not:\r\n-                        return IsNotConditionNode(\r\n-                            left=left,\r\n-                            keywordIs=\"IS\",\r\n-                            keywordNot=\"NOT\"\r\n-                        )\r\n-                    else:\r\n-                        # IS NULL (without NOT)\r\n-                        return BinaryConditionNode(\r\n-                            left=left,\r\n-                            operator=\"IS\",\r\n-                            right=expr_builder.build_expression(expressions[1]) if len(expressions) > 1 else None\r\n-                        )\r\n-\r\n-            # Single expression - just convert to condition\r\n-            elif len(expressions) == 1:\r\n-                return expr_builder.build_expression(expressions[0])\r\n-\r\n-        # Fallback - try to build as expression\r\n-        return expr_builder.build_expression(ctx)\r\n-\r\n-    def _expression_to_condition(self, expr_ctx, expr_builder):\r\n-        \"\"\"Helper to convert an expression context to a condition\"\"\"\r\n-        # Check if the expression itself contains operators that make it a condition\r\n-        if hasattr(expr_ctx, 'binaryOp') and expr_ctx.binaryOp():\r\n-            expressions = expr_ctx.expression() if hasattr(expr_ctx, 'expression') else []\r\n-            if isinstance(expressions, list) and len(expressions) >= 2:\r\n-                left = expr_builder.build_expression(expressions[0])\r\n-                right = expr_builder.build_expression(expressions[1])\r\n-                operator = expr_ctx.binaryOp().getText()\r\n-                from Ast.condition_nodes import BinaryConditionNode\r\n-                return BinaryConditionNode(left=left, operator=operator, right=right)\r\n+            # No operator or couldn't process, just add the primary\r\n+            conditions.append(expr_builder.build_primary(primaries[i]))\r\n+            i += 1\r\n         \r\n-        # Otherwise, just build it as an expression (which can be used as a condition)\r\n-        return expr_builder.build_expression(expr_ctx)\n+        # Now handle logical operators (AND/OR) to combine conditions\r\n+        # We need to track which operators go between which conditions\r\n+        logical_operators = []\r\n+        for op in operators:\r\n+            if op.upper() in ('AND', 'OR'):\r\n+                logical_operators.append(op.upper())\r\n+        \r\n+        # Combine conditions with logical operators\r\n+        if len(conditions) == 1:\r\n+            return conditions[0]\r\n+        \r\n+        # Build left-to-right for now (can improve with precedence later)\r\n+        result = conditions[0]\r\n+        op_idx = 0\r\n+        \r\n+        for i in range(1, len(conditions)):\r\n+            if op_idx < len(logical_operators):\r\n+                result = LogicalConditionNode(\r\n+                    left=result,\r\n+                    operator=logical_operators[op_idx],\r\n+                    right=conditions[i]\r\n+                )\r\n+                op_idx += 1\r\n+            else:\r\n+                # No more operators, shouldn't happen but handle gracefully\r\n+                break\r\n+        \r\n+        return result\n\\ No newline at end of file\n"
                }
            ],
            "date": 1768865211626,
            "name": "Commit-0",
            "content": "class ConditionBuilder:\n    \"\"\"Builder for condition AST nodes\"\"\"\n\n    def build_condition(self, ctx):\n        \"\"\"Build a condition node from context\"\"\"\n        from builders.expression_builder import ExpressionBuilder\n        from Ast.condition_nodes import BinaryConditionNode, InConditionNode, IsNotConditionNode, ParenthesizedConditionNode, LogicalConditionNode\n        expr_builder = ExpressionBuilder()\n\n        if hasattr(ctx, 'expression') and len(ctx.expression()) == 2:\n            left = expr_builder.build_expression(ctx.expression(0))\n            right = expr_builder.build_expression(ctx.expression(1))\n            operator = None\n            if hasattr(ctx, 'OPERATOR') and ctx.OPERATOR():\n                operator = ctx.OPERATOR().getText()\n            elif hasattr(ctx, 'binaryOp') and ctx.binaryOp():\n                operator = ctx.binaryOp().getText()\n            elif hasattr(ctx, 'KEYWORD') and ctx.KEYWORD():\n                keywords = ctx.KEYWORD()\n                if len(keywords) == 1:\n                    operator = keywords[0].getText()\n            return BinaryConditionNode(left=left, operator=operator, right=right)\n\n        elif hasattr(ctx, 'expressionList') and ctx.expressionList():\n            left = expr_builder.build_expression(ctx.expression(0))\n            expressionList = expr_builder.build_expression_list(\n                ctx.expressionList())\n            keywordIn = \"IN\"\n            keywordNot = \"NOT\" if \"NOT\" in ctx.getText().upper() else None\n            return InConditionNode(\n                left=left,\n                keywordIn=keywordIn,\n                expressionList=expressionList,\n                keywordNot=keywordNot\n            )\n\n        elif \"IS\" in ctx.getText().upper() and hasattr(ctx, 'expression') and len(ctx.expression()) == 1:\n            left = expr_builder.build_expression(ctx.expression(0))\n            keywordIs = \"IS\"\n            keywordNot = \"NOT\" if \"NOT\" in ctx.getText().upper() else None\n            return IsNotConditionNode(\n                left=left,\n                keywordIs=keywordIs,\n                keywordNot=keywordNot\n            )\n\n        elif hasattr(ctx, 'condition') and len(ctx.condition()) == 1:\n            condition = self.build_condition(ctx.condition(0))\n            return ParenthesizedConditionNode(condition=condition)\n\n        elif hasattr(ctx, 'condition') and len(ctx.condition()) == 2:\n            left = self.build_condition(ctx.condition(0))\n            right = self.build_condition(ctx.condition(1))\n            operator = \"AND\" if \"AND\" in ctx.getText().upper() else \"OR\"\n            return LogicalConditionNode(left=left, operator=operator, right=right)\n\n        # Fallback for EXISTS or other conditions\n        from dataclasses import dataclass\n\n        @dataclass\n        class GenericConditionNode:\n            type: str\n            text: str\n        return GenericConditionNode(type=\"Condition\", text=ctx.getText()[:50])\n"
        }
    ]
}