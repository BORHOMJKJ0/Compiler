{
    "sourceFile": "builders/expression_builder.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 5,
            "patches": [
                {
                    "date": 1768866022251,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1768866028594,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,9 +48,8 @@\n             text: str\n         return UnknownExpressionNode(type=\"UnknownExpression\", text=ctx.getText()[:50])\n \n     def build_primary(self, ctx):\n-        \"\"\"Build primary expression\"\"\"\n         from Ast.expression_nodes import LiteralExpressionNode, VariableExpressionNode\n         \n         if hasattr(ctx, 'literal') and ctx.literal():\n             return self.build_literal(ctx.literal())\n"
                },
                {
                    "date": 1768866039659,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -72,9 +72,8 @@\n         \n         return None\n \n     def build_literal(self, ctx):\n-        \"\"\"Build a literal expression node\"\"\"\n         from Ast.expression_nodes import LiteralExpressionNode\n         if hasattr(ctx, 'NUMBER') and ctx.NUMBER():\n             value = ctx.NUMBER().getText()\n             return LiteralExpressionNode(value=value, literal_type=\"NUMBER\")\n"
                },
                {
                    "date": 1768866045521,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -99,9 +99,8 @@\n             columnName = ctx.getText()\n         return ColumnReferenceExpressionNode(table_name=tableName, column_name=columnName)\n \n     def build_function_call(self, ctx):\n-        \"\"\"Build a function call node\"\"\"\n         from Ast.expression_nodes import FunctionCallExpressionNode\n         functionName = ctx.getChild(0).getText()\n         expressionList = self.build_expression_list(ctx.expressionList()) if hasattr(ctx, 'expressionList') and ctx.expressionList() else None\n         return FunctionCallExpressionNode(function_name=functionName, arguments=expressionList)\n"
                },
                {
                    "date": 1768866053912,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,8 @@\n \n class ExpressionBuilder:\n \n     def build_expression(self, ctx):\n-        \"\"\"Build an expression node from context\"\"\"\n         from Ast.expression_nodes import ParenthesizedExpressionNode, BinaryExpressionNode, VariableExpressionNode, LiteralExpressionNode\n         \n         if hasattr(ctx, 'primary') and ctx.primary():\n             return self.build_primary(ctx.primary())\n@@ -88,9 +87,8 @@\n             # Fallback to text (NULL, etc)\n             return LiteralExpressionNode(value=ctx.getText(), literal_type=\"KEYWORD\")\n \n     def build_column_reference(self, ctx):\n-        \"\"\"Build a column reference node\"\"\"\n         from Ast.expression_nodes import ColumnReferenceExpressionNode\n         tableName = None\n         columnName = None\n         if hasattr(ctx, 'columnName') and ctx.columnName():\n@@ -107,18 +105,16 @@\n         expressionList = self.build_expression_list(ctx.expressionList()) if hasattr(ctx, 'expressionList') and ctx.expressionList() else None\n         return FunctionCallExpressionNode(function_name=functionName, arguments=expressionList)\n \n     def build_expression_list(self, ctx):\n-        \"\"\"Build a list of expressions\"\"\"\n         expressions = []\n         for expression in ctx.expression():\n             expr = self.build_expression(expression)\n             if expr is not None:\n                 expressions.append(expr)\n         return expressions\n \n     def build_case_expression(self, ctx):\n-        \"\"\"Build a CASE expression node\"\"\"\n         from Ast.expression_nodes import CaseExpressionNode\n         whenClauseList = []\n         if hasattr(ctx, 'whenClause'):\n             for whenClause in ctx.whenClause():\n@@ -133,9 +129,8 @@\n             keywordEnd=\"END\"\n         )\n \n     def build_when_clause(self, ctx):\n-        \"\"\"Build a WHEN clause node\"\"\"\n         from Ast.expression_nodes import WhenClauseNode\n         from .condition_builder import ConditionBuilder\n         condition_builder = ConditionBuilder()\n \n"
                },
                {
                    "date": 1768866060148,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,12 +4,12 @@\n class ExpressionBuilder:\n \n     def build_expression(self, ctx):\n         from Ast.expression_nodes import ParenthesizedExpressionNode, BinaryExpressionNode, VariableExpressionNode, LiteralExpressionNode\n-        \n+\n         if hasattr(ctx, 'primary') and ctx.primary():\n             return self.build_primary(ctx.primary())\n-        \n+\n         if hasattr(ctx, 'literal') and ctx.literal():\n             return self.build_literal(ctx.literal())\n         elif hasattr(ctx, 'columnReference') and ctx.columnReference():\n             return self.build_column_reference(ctx.columnReference())\n@@ -38,20 +38,21 @@\n             return LiteralExpressionNode(value=value, literal_type=\"STRING_SINGLE\")\n         elif hasattr(ctx, 'STRING_DOUBLE') and ctx.STRING_DOUBLE():\n             value = ctx.STRING_DOUBLE().getText()\n             return LiteralExpressionNode(value=value, literal_type=\"STRING_DOUBLE\")\n-        \n+\n         # Fallback for unknown expression types\n         from dataclasses import dataclass\n+\n         @dataclass\n         class UnknownExpressionNode:\n             type: str\n             text: str\n         return UnknownExpressionNode(type=\"UnknownExpression\", text=ctx.getText()[:50])\n \n     def build_primary(self, ctx):\n         from Ast.expression_nodes import LiteralExpressionNode, VariableExpressionNode\n-        \n+\n         if hasattr(ctx, 'literal') and ctx.literal():\n             return self.build_literal(ctx.literal())\n         elif hasattr(ctx, 'columnReference') and ctx.columnReference():\n             return self.build_column_reference(ctx.columnReference())\n@@ -68,9 +69,9 @@\n             if isinstance(inner, LiteralExpressionNode):\n                 inner.value = op + inner.value\n                 return inner\n             return inner\n-        \n+\n         return None\n \n     def build_literal(self, ctx):\n         from Ast.expression_nodes import LiteralExpressionNode\n@@ -101,9 +102,10 @@\n \n     def build_function_call(self, ctx):\n         from Ast.expression_nodes import FunctionCallExpressionNode\n         functionName = ctx.getChild(0).getText()\n-        expressionList = self.build_expression_list(ctx.expressionList()) if hasattr(ctx, 'expressionList') and ctx.expressionList() else None\n+        expressionList = self.build_expression_list(ctx.expressionList()) if hasattr(\n+            ctx, 'expressionList') and ctx.expressionList() else None\n         return FunctionCallExpressionNode(function_name=functionName, arguments=expressionList)\n \n     def build_expression_list(self, ctx):\n         expressions = []\n@@ -120,9 +122,10 @@\n             for whenClause in ctx.whenClause():\n                 clause = self.build_when_clause(whenClause)\n                 if clause is not None:\n                     whenClauseList.append(clause)\n-        elseClause = self.build_else_clause(ctx.elseClause()) if hasattr(ctx, 'elseClause') and ctx.elseClause() else None\n+        elseClause = self.build_else_clause(ctx.elseClause()) if hasattr(\n+            ctx, 'elseClause') and ctx.elseClause() else None\n         return CaseExpressionNode(\n             keywordCase=\"CASE\",\n             whenClauseList=whenClauseList,\n             elseClause=elseClause,\n@@ -143,15 +146,13 @@\n             expression=expression\n         )\n \n     def build_else_clause(self, ctx):\n-        \"\"\"Build an ELSE clause node\"\"\"\n         from Ast.expression_nodes import ElseClauseNode\n         expression = self.build_expression(ctx.expression())\n         return ElseClauseNode(keywordElse=\"ELSE\", expression=expression)\n \n     def build_table_name(self, ctx):\n-        \"\"\"Build a table name node\"\"\"\n         text = ctx.getText()\n         if '.' in text:\n             parts = text.split('.')\n             schema = parts[0].strip('[]')\n"
                }
            ],
            "date": 1768866022251,
            "name": "Commit-0",
            "content": "from Ast.statement_nodes import TableNameNode\n\n\nclass ExpressionBuilder:\n\n    def build_expression(self, ctx):\n        \"\"\"Build an expression node from context\"\"\"\n        from Ast.expression_nodes import ParenthesizedExpressionNode, BinaryExpressionNode, VariableExpressionNode, LiteralExpressionNode\n        \n        if hasattr(ctx, 'primary') and ctx.primary():\n            return self.build_primary(ctx.primary())\n        \n        if hasattr(ctx, 'literal') and ctx.literal():\n            return self.build_literal(ctx.literal())\n        elif hasattr(ctx, 'columnReference') and ctx.columnReference():\n            return self.build_column_reference(ctx.columnReference())\n        elif hasattr(ctx, 'functionCall') and ctx.functionCall():\n            return self.build_function_call(ctx.functionCall())\n        elif hasattr(ctx, 'caseExpression') and ctx.caseExpression():\n            return self.build_case_expression(ctx.caseExpression())\n        elif hasattr(ctx, 'LPAREN') and ctx.LPAREN() and hasattr(ctx, 'RPAREN') and ctx.RPAREN():\n            expression = self.build_expression(ctx.expression(0))\n            return ParenthesizedExpressionNode(expression=expression)\n        elif hasattr(ctx, 'binaryOp') and ctx.binaryOp() and len(ctx.expression()) == 2:\n            left = self.build_expression(ctx.expression(0))\n            operator = ctx.binaryOp().getText()\n            right = self.build_expression(ctx.expression(1))\n            return BinaryExpressionNode(left=left, operator=operator, right=right)\n        elif hasattr(ctx, 'OPERATOR') and ctx.OPERATOR() and len(ctx.expression()) == 2:\n            left = self.build_expression(ctx.expression(0))\n            operator = ctx.OPERATOR().getText()\n            right = self.build_expression(ctx.expression(1))\n            return BinaryExpressionNode(left=left, operator=operator, right=right)\n        elif hasattr(ctx, 'VARIABLE') and ctx.VARIABLE():\n            variableName = ctx.VARIABLE().getText()\n            return VariableExpressionNode(variable_name=variableName)\n        elif hasattr(ctx, 'STRING_SINGLE') and ctx.STRING_SINGLE():\n            value = ctx.STRING_SINGLE().getText()\n            return LiteralExpressionNode(value=value, literal_type=\"STRING_SINGLE\")\n        elif hasattr(ctx, 'STRING_DOUBLE') and ctx.STRING_DOUBLE():\n            value = ctx.STRING_DOUBLE().getText()\n            return LiteralExpressionNode(value=value, literal_type=\"STRING_DOUBLE\")\n        \n        # Fallback for unknown expression types\n        from dataclasses import dataclass\n        @dataclass\n        class UnknownExpressionNode:\n            type: str\n            text: str\n        return UnknownExpressionNode(type=\"UnknownExpression\", text=ctx.getText()[:50])\n\n    def build_primary(self, ctx):\n        \"\"\"Build primary expression\"\"\"\n        from Ast.expression_nodes import LiteralExpressionNode, VariableExpressionNode\n        \n        if hasattr(ctx, 'literal') and ctx.literal():\n            return self.build_literal(ctx.literal())\n        elif hasattr(ctx, 'columnReference') and ctx.columnReference():\n            return self.build_column_reference(ctx.columnReference())\n        elif hasattr(ctx, 'functionCall') and ctx.functionCall():\n            return self.build_function_call(ctx.functionCall())\n        elif hasattr(ctx, 'VARIABLE') and ctx.VARIABLE():\n            return VariableExpressionNode(variable_name=ctx.VARIABLE().getText())\n        elif hasattr(ctx, 'expression') and ctx.expression():\n            return self.build_expression(ctx.expression())\n        elif hasattr(ctx, 'OPERATOR') and ctx.OPERATOR() and ctx.primary():\n            # Unary operator like -1\n            op = ctx.OPERATOR().getText()\n            inner = self.build_primary(ctx.primary())\n            if isinstance(inner, LiteralExpressionNode):\n                inner.value = op + inner.value\n                return inner\n            return inner\n        \n        return None\n\n    def build_literal(self, ctx):\n        \"\"\"Build a literal expression node\"\"\"\n        from Ast.expression_nodes import LiteralExpressionNode\n        if hasattr(ctx, 'NUMBER') and ctx.NUMBER():\n            value = ctx.NUMBER().getText()\n            return LiteralExpressionNode(value=value, literal_type=\"NUMBER\")\n        elif hasattr(ctx, 'STRING_SINGLE') and ctx.STRING_SINGLE():\n            value = ctx.STRING_SINGLE().getText()\n            return LiteralExpressionNode(value=value, literal_type=\"STRING_SINGLE\")\n        elif hasattr(ctx, 'STRING_DOUBLE') and ctx.STRING_DOUBLE():\n            value = ctx.STRING_DOUBLE().getText()\n            return LiteralExpressionNode(value=value, literal_type=\"STRING_DOUBLE\")\n        else:\n            # Fallback to text (NULL, etc)\n            return LiteralExpressionNode(value=ctx.getText(), literal_type=\"KEYWORD\")\n\n    def build_column_reference(self, ctx):\n        \"\"\"Build a column reference node\"\"\"\n        from Ast.expression_nodes import ColumnReferenceExpressionNode\n        tableName = None\n        columnName = None\n        if hasattr(ctx, 'columnName') and ctx.columnName():\n            if hasattr(ctx, 'tableName') and ctx.tableName():\n                tableName = self.build_table_name(ctx.tableName())\n            columnName = ctx.columnName().getText()\n        else:\n            columnName = ctx.getText()\n        return ColumnReferenceExpressionNode(table_name=tableName, column_name=columnName)\n\n    def build_function_call(self, ctx):\n        \"\"\"Build a function call node\"\"\"\n        from Ast.expression_nodes import FunctionCallExpressionNode\n        functionName = ctx.getChild(0).getText()\n        expressionList = self.build_expression_list(ctx.expressionList()) if hasattr(ctx, 'expressionList') and ctx.expressionList() else None\n        return FunctionCallExpressionNode(function_name=functionName, arguments=expressionList)\n\n    def build_expression_list(self, ctx):\n        \"\"\"Build a list of expressions\"\"\"\n        expressions = []\n        for expression in ctx.expression():\n            expr = self.build_expression(expression)\n            if expr is not None:\n                expressions.append(expr)\n        return expressions\n\n    def build_case_expression(self, ctx):\n        \"\"\"Build a CASE expression node\"\"\"\n        from Ast.expression_nodes import CaseExpressionNode\n        whenClauseList = []\n        if hasattr(ctx, 'whenClause'):\n            for whenClause in ctx.whenClause():\n                clause = self.build_when_clause(whenClause)\n                if clause is not None:\n                    whenClauseList.append(clause)\n        elseClause = self.build_else_clause(ctx.elseClause()) if hasattr(ctx, 'elseClause') and ctx.elseClause() else None\n        return CaseExpressionNode(\n            keywordCase=\"CASE\",\n            whenClauseList=whenClauseList,\n            elseClause=elseClause,\n            keywordEnd=\"END\"\n        )\n\n    def build_when_clause(self, ctx):\n        \"\"\"Build a WHEN clause node\"\"\"\n        from Ast.expression_nodes import WhenClauseNode\n        from .condition_builder import ConditionBuilder\n        condition_builder = ConditionBuilder()\n\n        condition = condition_builder.build_condition(ctx.condition())\n        expression = self.build_expression(ctx.expression())\n        return WhenClauseNode(\n            keywordWhen=\"WHEN\",\n            condition=condition,\n            keyword=\"THEN\",\n            expression=expression\n        )\n\n    def build_else_clause(self, ctx):\n        \"\"\"Build an ELSE clause node\"\"\"\n        from Ast.expression_nodes import ElseClauseNode\n        expression = self.build_expression(ctx.expression())\n        return ElseClauseNode(keywordElse=\"ELSE\", expression=expression)\n\n    def build_table_name(self, ctx):\n        \"\"\"Build a table name node\"\"\"\n        text = ctx.getText()\n        if '.' in text:\n            parts = text.split('.')\n            schema = parts[0].strip('[]')\n            name = parts[-1].strip('[]')\n        else:\n            schema = None\n            name = text.strip('[]')\n\n        return TableNameNode(schema=schema, name=name)\n"
        }
    ]
}