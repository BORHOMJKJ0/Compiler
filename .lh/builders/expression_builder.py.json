{
    "sourceFile": "builders/expression_builder.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 23,
            "patches": [
                {
                    "date": 1768866022251,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1768866028594,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,9 +48,8 @@\n             text: str\n         return UnknownExpressionNode(type=\"UnknownExpression\", text=ctx.getText()[:50])\n \n     def build_primary(self, ctx):\n-        \"\"\"Build primary expression\"\"\"\n         from Ast.expression_nodes import LiteralExpressionNode, VariableExpressionNode\n         \n         if hasattr(ctx, 'literal') and ctx.literal():\n             return self.build_literal(ctx.literal())\n"
                },
                {
                    "date": 1768866039659,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -72,9 +72,8 @@\n         \n         return None\n \n     def build_literal(self, ctx):\n-        \"\"\"Build a literal expression node\"\"\"\n         from Ast.expression_nodes import LiteralExpressionNode\n         if hasattr(ctx, 'NUMBER') and ctx.NUMBER():\n             value = ctx.NUMBER().getText()\n             return LiteralExpressionNode(value=value, literal_type=\"NUMBER\")\n"
                },
                {
                    "date": 1768866045521,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -99,9 +99,8 @@\n             columnName = ctx.getText()\n         return ColumnReferenceExpressionNode(table_name=tableName, column_name=columnName)\n \n     def build_function_call(self, ctx):\n-        \"\"\"Build a function call node\"\"\"\n         from Ast.expression_nodes import FunctionCallExpressionNode\n         functionName = ctx.getChild(0).getText()\n         expressionList = self.build_expression_list(ctx.expressionList()) if hasattr(ctx, 'expressionList') and ctx.expressionList() else None\n         return FunctionCallExpressionNode(function_name=functionName, arguments=expressionList)\n"
                },
                {
                    "date": 1768866053912,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,8 @@\n \n class ExpressionBuilder:\n \n     def build_expression(self, ctx):\n-        \"\"\"Build an expression node from context\"\"\"\n         from Ast.expression_nodes import ParenthesizedExpressionNode, BinaryExpressionNode, VariableExpressionNode, LiteralExpressionNode\n         \n         if hasattr(ctx, 'primary') and ctx.primary():\n             return self.build_primary(ctx.primary())\n@@ -88,9 +87,8 @@\n             # Fallback to text (NULL, etc)\n             return LiteralExpressionNode(value=ctx.getText(), literal_type=\"KEYWORD\")\n \n     def build_column_reference(self, ctx):\n-        \"\"\"Build a column reference node\"\"\"\n         from Ast.expression_nodes import ColumnReferenceExpressionNode\n         tableName = None\n         columnName = None\n         if hasattr(ctx, 'columnName') and ctx.columnName():\n@@ -107,18 +105,16 @@\n         expressionList = self.build_expression_list(ctx.expressionList()) if hasattr(ctx, 'expressionList') and ctx.expressionList() else None\n         return FunctionCallExpressionNode(function_name=functionName, arguments=expressionList)\n \n     def build_expression_list(self, ctx):\n-        \"\"\"Build a list of expressions\"\"\"\n         expressions = []\n         for expression in ctx.expression():\n             expr = self.build_expression(expression)\n             if expr is not None:\n                 expressions.append(expr)\n         return expressions\n \n     def build_case_expression(self, ctx):\n-        \"\"\"Build a CASE expression node\"\"\"\n         from Ast.expression_nodes import CaseExpressionNode\n         whenClauseList = []\n         if hasattr(ctx, 'whenClause'):\n             for whenClause in ctx.whenClause():\n@@ -133,9 +129,8 @@\n             keywordEnd=\"END\"\n         )\n \n     def build_when_clause(self, ctx):\n-        \"\"\"Build a WHEN clause node\"\"\"\n         from Ast.expression_nodes import WhenClauseNode\n         from .condition_builder import ConditionBuilder\n         condition_builder = ConditionBuilder()\n \n"
                },
                {
                    "date": 1768866060148,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,12 +4,12 @@\n class ExpressionBuilder:\n \n     def build_expression(self, ctx):\n         from Ast.expression_nodes import ParenthesizedExpressionNode, BinaryExpressionNode, VariableExpressionNode, LiteralExpressionNode\n-        \n+\n         if hasattr(ctx, 'primary') and ctx.primary():\n             return self.build_primary(ctx.primary())\n-        \n+\n         if hasattr(ctx, 'literal') and ctx.literal():\n             return self.build_literal(ctx.literal())\n         elif hasattr(ctx, 'columnReference') and ctx.columnReference():\n             return self.build_column_reference(ctx.columnReference())\n@@ -38,20 +38,21 @@\n             return LiteralExpressionNode(value=value, literal_type=\"STRING_SINGLE\")\n         elif hasattr(ctx, 'STRING_DOUBLE') and ctx.STRING_DOUBLE():\n             value = ctx.STRING_DOUBLE().getText()\n             return LiteralExpressionNode(value=value, literal_type=\"STRING_DOUBLE\")\n-        \n+\n         # Fallback for unknown expression types\n         from dataclasses import dataclass\n+\n         @dataclass\n         class UnknownExpressionNode:\n             type: str\n             text: str\n         return UnknownExpressionNode(type=\"UnknownExpression\", text=ctx.getText()[:50])\n \n     def build_primary(self, ctx):\n         from Ast.expression_nodes import LiteralExpressionNode, VariableExpressionNode\n-        \n+\n         if hasattr(ctx, 'literal') and ctx.literal():\n             return self.build_literal(ctx.literal())\n         elif hasattr(ctx, 'columnReference') and ctx.columnReference():\n             return self.build_column_reference(ctx.columnReference())\n@@ -68,9 +69,9 @@\n             if isinstance(inner, LiteralExpressionNode):\n                 inner.value = op + inner.value\n                 return inner\n             return inner\n-        \n+\n         return None\n \n     def build_literal(self, ctx):\n         from Ast.expression_nodes import LiteralExpressionNode\n@@ -101,9 +102,10 @@\n \n     def build_function_call(self, ctx):\n         from Ast.expression_nodes import FunctionCallExpressionNode\n         functionName = ctx.getChild(0).getText()\n-        expressionList = self.build_expression_list(ctx.expressionList()) if hasattr(ctx, 'expressionList') and ctx.expressionList() else None\n+        expressionList = self.build_expression_list(ctx.expressionList()) if hasattr(\n+            ctx, 'expressionList') and ctx.expressionList() else None\n         return FunctionCallExpressionNode(function_name=functionName, arguments=expressionList)\n \n     def build_expression_list(self, ctx):\n         expressions = []\n@@ -120,9 +122,10 @@\n             for whenClause in ctx.whenClause():\n                 clause = self.build_when_clause(whenClause)\n                 if clause is not None:\n                     whenClauseList.append(clause)\n-        elseClause = self.build_else_clause(ctx.elseClause()) if hasattr(ctx, 'elseClause') and ctx.elseClause() else None\n+        elseClause = self.build_else_clause(ctx.elseClause()) if hasattr(\n+            ctx, 'elseClause') and ctx.elseClause() else None\n         return CaseExpressionNode(\n             keywordCase=\"CASE\",\n             whenClauseList=whenClauseList,\n             elseClause=elseClause,\n@@ -143,15 +146,13 @@\n             expression=expression\n         )\n \n     def build_else_clause(self, ctx):\n-        \"\"\"Build an ELSE clause node\"\"\"\n         from Ast.expression_nodes import ElseClauseNode\n         expression = self.build_expression(ctx.expression())\n         return ElseClauseNode(keywordElse=\"ELSE\", expression=expression)\n \n     def build_table_name(self, ctx):\n-        \"\"\"Build a table name node\"\"\"\n         text = ctx.getText()\n         if '.' in text:\n             parts = text.split('.')\n             schema = parts[0].strip('[]')\n"
                },
                {
                    "date": 1768913165059,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,164 +1,163 @@\n-from Ast.statement_nodes import TableNameNode\n-\n-\n-class ExpressionBuilder:\n-\n-    def build_expression(self, ctx):\n-        from Ast.expression_nodes import ParenthesizedExpressionNode, BinaryExpressionNode, VariableExpressionNode, LiteralExpressionNode\n-\n-        if hasattr(ctx, 'primary') and ctx.primary():\n-            return self.build_primary(ctx.primary())\n-\n-        if hasattr(ctx, 'literal') and ctx.literal():\n-            return self.build_literal(ctx.literal())\n-        elif hasattr(ctx, 'columnReference') and ctx.columnReference():\n-            return self.build_column_reference(ctx.columnReference())\n-        elif hasattr(ctx, 'functionCall') and ctx.functionCall():\n-            return self.build_function_call(ctx.functionCall())\n-        elif hasattr(ctx, 'caseExpression') and ctx.caseExpression():\n-            return self.build_case_expression(ctx.caseExpression())\n-        elif hasattr(ctx, 'LPAREN') and ctx.LPAREN() and hasattr(ctx, 'RPAREN') and ctx.RPAREN():\n-            expression = self.build_expression(ctx.expression(0))\n-            return ParenthesizedExpressionNode(expression=expression)\n-        elif hasattr(ctx, 'binaryOp') and ctx.binaryOp() and len(ctx.expression()) == 2:\n-            left = self.build_expression(ctx.expression(0))\n-            operator = ctx.binaryOp().getText()\n-            right = self.build_expression(ctx.expression(1))\n-            return BinaryExpressionNode(left=left, operator=operator, right=right)\n-        elif hasattr(ctx, 'OPERATOR') and ctx.OPERATOR() and len(ctx.expression()) == 2:\n-            left = self.build_expression(ctx.expression(0))\n-            operator = ctx.OPERATOR().getText()\n-            right = self.build_expression(ctx.expression(1))\n-            return BinaryExpressionNode(left=left, operator=operator, right=right)\n-        elif hasattr(ctx, 'VARIABLE') and ctx.VARIABLE():\n-            variableName = ctx.VARIABLE().getText()\n-            return VariableExpressionNode(variable_name=variableName)\n-        elif hasattr(ctx, 'STRING_SINGLE') and ctx.STRING_SINGLE():\n-            value = ctx.STRING_SINGLE().getText()\n-            return LiteralExpressionNode(value=value, literal_type=\"STRING_SINGLE\")\n-        elif hasattr(ctx, 'STRING_DOUBLE') and ctx.STRING_DOUBLE():\n-            value = ctx.STRING_DOUBLE().getText()\n-            return LiteralExpressionNode(value=value, literal_type=\"STRING_DOUBLE\")\n-\n-        # Fallback for unknown expression types\n-        from dataclasses import dataclass\n-\n-        @dataclass\n-        class UnknownExpressionNode:\n-            type: str\n-            text: str\n-        return UnknownExpressionNode(type=\"UnknownExpression\", text=ctx.getText()[:50])\n-\n-    def build_primary(self, ctx):\n-        from Ast.expression_nodes import LiteralExpressionNode, VariableExpressionNode\n-\n-        if hasattr(ctx, 'literal') and ctx.literal():\n-            return self.build_literal(ctx.literal())\n-        elif hasattr(ctx, 'columnReference') and ctx.columnReference():\n-            return self.build_column_reference(ctx.columnReference())\n-        elif hasattr(ctx, 'functionCall') and ctx.functionCall():\n-            return self.build_function_call(ctx.functionCall())\n-        elif hasattr(ctx, 'VARIABLE') and ctx.VARIABLE():\n-            return VariableExpressionNode(variable_name=ctx.VARIABLE().getText())\n-        elif hasattr(ctx, 'expression') and ctx.expression():\n-            return self.build_expression(ctx.expression())\n-        elif hasattr(ctx, 'OPERATOR') and ctx.OPERATOR() and ctx.primary():\n-            # Unary operator like -1\n-            op = ctx.OPERATOR().getText()\n-            inner = self.build_primary(ctx.primary())\n-            if isinstance(inner, LiteralExpressionNode):\n-                inner.value = op + inner.value\n-                return inner\n-            return inner\n-\n-        return None\n-\n-    def build_literal(self, ctx):\n-        from Ast.expression_nodes import LiteralExpressionNode\n-        if hasattr(ctx, 'NUMBER') and ctx.NUMBER():\n-            value = ctx.NUMBER().getText()\n-            return LiteralExpressionNode(value=value, literal_type=\"NUMBER\")\n-        elif hasattr(ctx, 'STRING_SINGLE') and ctx.STRING_SINGLE():\n-            value = ctx.STRING_SINGLE().getText()\n-            return LiteralExpressionNode(value=value, literal_type=\"STRING_SINGLE\")\n-        elif hasattr(ctx, 'STRING_DOUBLE') and ctx.STRING_DOUBLE():\n-            value = ctx.STRING_DOUBLE().getText()\n-            return LiteralExpressionNode(value=value, literal_type=\"STRING_DOUBLE\")\n-        else:\n-            # Fallback to text (NULL, etc)\n-            return LiteralExpressionNode(value=ctx.getText(), literal_type=\"KEYWORD\")\n-\n-    def build_column_reference(self, ctx):\n-        from Ast.expression_nodes import ColumnReferenceExpressionNode\n-        tableName = None\n-        columnName = None\n-        if hasattr(ctx, 'columnName') and ctx.columnName():\n-            if hasattr(ctx, 'tableName') and ctx.tableName():\n-                tableName = self.build_table_name(ctx.tableName())\n-            columnName = ctx.columnName().getText()\n-        else:\n-            columnName = ctx.getText()\n-        return ColumnReferenceExpressionNode(table_name=tableName, column_name=columnName)\n-\n-    def build_function_call(self, ctx):\n-        from Ast.expression_nodes import FunctionCallExpressionNode\n-        functionName = ctx.getChild(0).getText()\n-        expressionList = self.build_expression_list(ctx.expressionList()) if hasattr(\n-            ctx, 'expressionList') and ctx.expressionList() else None\n-        return FunctionCallExpressionNode(function_name=functionName, arguments=expressionList)\n-\n-    def build_expression_list(self, ctx):\n-        expressions = []\n-        for expression in ctx.expression():\n-            expr = self.build_expression(expression)\n-            if expr is not None:\n-                expressions.append(expr)\n-        return expressions\n-\n-    def build_case_expression(self, ctx):\n-        from Ast.expression_nodes import CaseExpressionNode\n-        whenClauseList = []\n-        if hasattr(ctx, 'whenClause'):\n-            for whenClause in ctx.whenClause():\n-                clause = self.build_when_clause(whenClause)\n-                if clause is not None:\n-                    whenClauseList.append(clause)\n-        elseClause = self.build_else_clause(ctx.elseClause()) if hasattr(\n-            ctx, 'elseClause') and ctx.elseClause() else None\n-        return CaseExpressionNode(\n-            keywordCase=\"CASE\",\n-            whenClauseList=whenClauseList,\n-            elseClause=elseClause,\n-            keywordEnd=\"END\"\n-        )\n-\n-    def build_when_clause(self, ctx):\n-        from Ast.expression_nodes import WhenClauseNode\n-        from .condition_builder import ConditionBuilder\n-        condition_builder = ConditionBuilder()\n-\n-        condition = condition_builder.build_condition(ctx.condition())\n-        expression = self.build_expression(ctx.expression())\n-        return WhenClauseNode(\n-            keywordWhen=\"WHEN\",\n-            condition=condition,\n-            keyword=\"THEN\",\n-            expression=expression\n-        )\n-\n-    def build_else_clause(self, ctx):\n-        from Ast.expression_nodes import ElseClauseNode\n-        expression = self.build_expression(ctx.expression())\n-        return ElseClauseNode(keywordElse=\"ELSE\", expression=expression)\n-\n-    def build_table_name(self, ctx):\n-        text = ctx.getText()\n-        if '.' in text:\n-            parts = text.split('.')\n-            schema = parts[0].strip('[]')\n-            name = parts[-1].strip('[]')\n-        else:\n-            schema = None\n-            name = text.strip('[]')\n-\n-        return TableNameNode(schema=schema, name=name)\n+from Ast.statement_nodes import TableNameNode\r\n+\r\n+\r\n+class ExpressionBuilder:\r\n+\r\n+    def build_expression(self, ctx):\r\n+        from Ast.expression_nodes import ParenthesizedExpressionNode, BinaryExpressionNode, VariableExpressionNode, LiteralExpressionNode\r\n+\r\n+        if hasattr(ctx, 'primary') and ctx.primary():\r\n+            return self.build_primary(ctx.primary())\r\n+\r\n+        if hasattr(ctx, 'literal') and ctx.literal():\r\n+            return self.build_literal(ctx.literal())\r\n+        elif hasattr(ctx, 'columnReference') and ctx.columnReference():\r\n+            return self.build_column_reference(ctx.columnReference())\r\n+        elif hasattr(ctx, 'functionCall') and ctx.functionCall():\r\n+            return self.build_function_call(ctx.functionCall())\r\n+        elif hasattr(ctx, 'caseExpression') and ctx.caseExpression():\r\n+            return self.build_case_expression(ctx.caseExpression())\r\n+        elif hasattr(ctx, 'LPAREN') and ctx.LPAREN() and hasattr(ctx, 'RPAREN') and ctx.RPAREN():\r\n+            expression = self.build_expression(ctx.expression(0))\r\n+            return ParenthesizedExpressionNode(expression=expression)\r\n+        elif hasattr(ctx, 'binaryOp') and ctx.binaryOp() and len(ctx.expression()) == 2:\r\n+            left = self.build_expression(ctx.expression(0))\r\n+            operator = ctx.binaryOp().getText()\r\n+            right = self.build_expression(ctx.expression(1))\r\n+            return BinaryExpressionNode(left=left, operator=operator, right=right)\r\n+        elif hasattr(ctx, 'OPERATOR') and ctx.OPERATOR() and len(ctx.expression()) == 2:\r\n+            left = self.build_expression(ctx.expression(0))\r\n+            operator = ctx.OPERATOR().getText()\r\n+            right = self.build_expression(ctx.expression(1))\r\n+            return BinaryExpressionNode(left=left, operator=operator, right=right)\r\n+        elif hasattr(ctx, 'VARIABLE') and ctx.VARIABLE():\r\n+            variableName = ctx.VARIABLE().getText()\r\n+            return VariableExpressionNode(variable_name=variableName)\r\n+        elif hasattr(ctx, 'STRING_SINGLE') and ctx.STRING_SINGLE():\r\n+            value = ctx.STRING_SINGLE().getText()\r\n+            return LiteralExpressionNode(value=value, literal_type=\"STRING_SINGLE\")\r\n+        elif hasattr(ctx, 'STRING_DOUBLE') and ctx.STRING_DOUBLE():\r\n+            value = ctx.STRING_DOUBLE().getText()\r\n+            return LiteralExpressionNode(value=value, literal_type=\"STRING_DOUBLE\")\r\n+\r\n+        # Fallback for unknown expression types\r\n+        from dataclasses import dataclass\r\n+\r\n+        @dataclass\r\n+        class UnknownExpressionNode:\r\n+            type: str\r\n+            text: str\r\n+        return UnknownExpressionNode(type=\"UnknownExpression\", text=ctx.getText()[:50])\r\n+\r\n+    def build_primary(self, ctx):\r\n+        from Ast.expression_nodes import LiteralExpressionNode, VariableExpressionNode\r\n+\r\n+        if hasattr(ctx, 'literal') and ctx.literal():\r\n+            return self.build_literal(ctx.literal())\r\n+        elif hasattr(ctx, 'columnReference') and ctx.columnReference():\r\n+            return self.build_column_reference(ctx.columnReference())\r\n+        elif hasattr(ctx, 'functionCall') and ctx.functionCall():\r\n+            return self.build_function_call(ctx.functionCall())\r\n+        elif hasattr(ctx, 'VARIABLE') and ctx.VARIABLE():\r\n+            return VariableExpressionNode(variable_name=ctx.VARIABLE().getText())\r\n+        elif hasattr(ctx, 'expression') and ctx.expression():\r\n+            return self.build_expression(ctx.expression())\r\n+        elif hasattr(ctx, 'OPERATOR') and ctx.OPERATOR() and ctx.primary():\r\n+            # Unary operator like -1\r\n+            op = ctx.OPERATOR().getText()\r\n+            inner = self.build_primary(ctx.primary())\r\n+            if isinstance(inner, LiteralExpressionNode):\r\n+                inner.value = op + inner.value\r\n+                return inner\r\n+            return inner\r\n+\r\n+        return None\r\n+\r\n+    def build_literal(self, ctx):\r\n+        from Ast.expression_nodes import LiteralExpressionNode\r\n+        if hasattr(ctx, 'NUMBER') and ctx.NUMBER():\r\n+            value = ctx.NUMBER().getText()\r\n+            return LiteralExpressionNode(value=value, literal_type=\"NUMBER\")\r\n+        elif hasattr(ctx, 'STRING_SINGLE') and ctx.STRING_SINGLE():\r\n+            value = ctx.STRING_SINGLE().getText()\r\n+            return LiteralExpressionNode(value=value, literal_type=\"STRING_SINGLE\")\r\n+        elif hasattr(ctx, 'STRING_DOUBLE') and ctx.STRING_DOUBLE():\r\n+            value = ctx.STRING_DOUBLE().getText()\r\n+            return LiteralExpressionNode(value=value, literal_type=\"STRING_DOUBLE\")\r\n+        else:\r\n+            return LiteralExpressionNode(value=ctx.getText(), literal_type=\"KEYWORD\")\r\n+\r\n+    def build_column_reference(self, ctx):\r\n+        from Ast.expression_nodes import ColumnReferenceExpressionNode\r\n+        tableName = None\r\n+        columnName = None\r\n+        if hasattr(ctx, 'columnName') and ctx.columnName():\r\n+            if hasattr(ctx, 'tableName') and ctx.tableName():\r\n+                tableName = self.build_table_name(ctx.tableName())\r\n+            columnName = ctx.columnName().getText()\r\n+        else:\r\n+            columnName = ctx.getText()\r\n+        return ColumnReferenceExpressionNode(table_name=tableName, column_name=columnName)\r\n+\r\n+    def build_function_call(self, ctx):\r\n+        from Ast.expression_nodes import FunctionCallExpressionNode\r\n+        functionName = ctx.getChild(0).getText()\r\n+        expressionList = self.build_expression_list(ctx.expressionList()) if hasattr(\r\n+            ctx, 'expressionList') and ctx.expressionList() else None\r\n+        return FunctionCallExpressionNode(function_name=functionName, arguments=expressionList)\r\n+\r\n+    def build_expression_list(self, ctx):\r\n+        expressions = []\r\n+        for expression in ctx.expression():\r\n+            expr = self.build_expression(expression)\r\n+            if expr is not None:\r\n+                expressions.append(expr)\r\n+        return expressions\r\n+\r\n+    def build_case_expression(self, ctx):\r\n+        from Ast.expression_nodes import CaseExpressionNode\r\n+        whenClauseList = []\r\n+        if hasattr(ctx, 'whenClause'):\r\n+            for whenClause in ctx.whenClause():\r\n+                clause = self.build_when_clause(whenClause)\r\n+                if clause is not None:\r\n+                    whenClauseList.append(clause)\r\n+        elseClause = self.build_else_clause(ctx.elseClause()) if hasattr(\r\n+            ctx, 'elseClause') and ctx.elseClause() else None\r\n+        return CaseExpressionNode(\r\n+            keywordCase=\"CASE\",\r\n+            whenClauseList=whenClauseList,\r\n+            elseClause=elseClause,\r\n+            keywordEnd=\"END\"\r\n+        )\r\n+\r\n+    def build_when_clause(self, ctx):\r\n+        from Ast.expression_nodes import WhenClauseNode\r\n+        from .condition_builder import ConditionBuilder\r\n+        condition_builder = ConditionBuilder()\r\n+\r\n+        condition = condition_builder.build_condition(ctx.condition())\r\n+        expression = self.build_expression(ctx.expression())\r\n+        return WhenClauseNode(\r\n+            keywordWhen=\"WHEN\",\r\n+            condition=condition,\r\n+            keyword=\"THEN\",\r\n+            expression=expression\r\n+        )\r\n+\r\n+    def build_else_clause(self, ctx):\r\n+        from Ast.expression_nodes import ElseClauseNode\r\n+        expression = self.build_expression(ctx.expression())\r\n+        return ElseClauseNode(keywordElse=\"ELSE\", expression=expression)\r\n+\r\n+    def build_table_name(self, ctx):\r\n+        text = ctx.getText()\r\n+        if '.' in text:\r\n+            parts = text.split('.')\r\n+            schema = parts[0].strip('[]')\r\n+            name = parts[-1].strip('[]')\r\n+        else:\r\n+            schema = None\r\n+            name = text.strip('[]')\r\n+\r\n+        return TableNameNode(schema=schema, name=name)\r\n"
                },
                {
                    "date": 1768913171822,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,162 @@\n+from Ast.statement_nodes import TableNameNode\r\n+\r\n+\r\n+class ExpressionBuilder:\r\n+\r\n+    def build_expression(self, ctx):\r\n+        from Ast.expression_nodes import ParenthesizedExpressionNode, BinaryExpressionNode, VariableExpressionNode, LiteralExpressionNode\r\n+\r\n+        if hasattr(ctx, 'primary') and ctx.primary():\r\n+            return self.build_primary(ctx.primary())\r\n+\r\n+        if hasattr(ctx, 'literal') and ctx.literal():\r\n+            return self.build_literal(ctx.literal())\r\n+        elif hasattr(ctx, 'columnReference') and ctx.columnReference():\r\n+            return self.build_column_reference(ctx.columnReference())\r\n+        elif hasattr(ctx, 'functionCall') and ctx.functionCall():\r\n+            return self.build_function_call(ctx.functionCall())\r\n+        elif hasattr(ctx, 'caseExpression') and ctx.caseExpression():\r\n+            return self.build_case_expression(ctx.caseExpression())\r\n+        elif hasattr(ctx, 'LPAREN') and ctx.LPAREN() and hasattr(ctx, 'RPAREN') and ctx.RPAREN():\r\n+            expression = self.build_expression(ctx.expression(0))\r\n+            return ParenthesizedExpressionNode(expression=expression)\r\n+        elif hasattr(ctx, 'binaryOp') and ctx.binaryOp() and len(ctx.expression()) == 2:\r\n+            left = self.build_expression(ctx.expression(0))\r\n+            operator = ctx.binaryOp().getText()\r\n+            right = self.build_expression(ctx.expression(1))\r\n+            return BinaryExpressionNode(left=left, operator=operator, right=right)\r\n+        elif hasattr(ctx, 'OPERATOR') and ctx.OPERATOR() and len(ctx.expression()) == 2:\r\n+            left = self.build_expression(ctx.expression(0))\r\n+            operator = ctx.OPERATOR().getText()\r\n+            right = self.build_expression(ctx.expression(1))\r\n+            return BinaryExpressionNode(left=left, operator=operator, right=right)\r\n+        elif hasattr(ctx, 'VARIABLE') and ctx.VARIABLE():\r\n+            variableName = ctx.VARIABLE().getText()\r\n+            return VariableExpressionNode(variable_name=variableName)\r\n+        elif hasattr(ctx, 'STRING_SINGLE') and ctx.STRING_SINGLE():\r\n+            value = ctx.STRING_SINGLE().getText()\r\n+            return LiteralExpressionNode(value=value, literal_type=\"STRING_SINGLE\")\r\n+        elif hasattr(ctx, 'STRING_DOUBLE') and ctx.STRING_DOUBLE():\r\n+            value = ctx.STRING_DOUBLE().getText()\r\n+            return LiteralExpressionNode(value=value, literal_type=\"STRING_DOUBLE\")\r\n+\r\n+        # Fallback for unknown expression types\r\n+        from dataclasses import dataclass\r\n+\r\n+        @dataclass\r\n+        class UnknownExpressionNode:\r\n+            type: str\r\n+            text: str\r\n+        return UnknownExpressionNode(type=\"UnknownExpression\", text=ctx.getText()[:50])\r\n+\r\n+    def build_primary(self, ctx):\r\n+        from Ast.expression_nodes import LiteralExpressionNode, VariableExpressionNode\r\n+\r\n+        if hasattr(ctx, 'literal') and ctx.literal():\r\n+            return self.build_literal(ctx.literal())\r\n+        elif hasattr(ctx, 'columnReference') and ctx.columnReference():\r\n+            return self.build_column_reference(ctx.columnReference())\r\n+        elif hasattr(ctx, 'functionCall') and ctx.functionCall():\r\n+            return self.build_function_call(ctx.functionCall())\r\n+        elif hasattr(ctx, 'VARIABLE') and ctx.VARIABLE():\r\n+            return VariableExpressionNode(variable_name=ctx.VARIABLE().getText())\r\n+        elif hasattr(ctx, 'expression') and ctx.expression():\r\n+            return self.build_expression(ctx.expression())\r\n+        elif hasattr(ctx, 'OPERATOR') and ctx.OPERATOR() and ctx.primary():\r\n+            op = ctx.OPERATOR().getText()\r\n+            inner = self.build_primary(ctx.primary())\r\n+            if isinstance(inner, LiteralExpressionNode):\r\n+                inner.value = op + inner.value\r\n+                return inner\r\n+            return inner\r\n+\r\n+        return None\r\n+\r\n+    def build_literal(self, ctx):\r\n+        from Ast.expression_nodes import LiteralExpressionNode\r\n+        if hasattr(ctx, 'NUMBER') and ctx.NUMBER():\r\n+            value = ctx.NUMBER().getText()\r\n+            return LiteralExpressionNode(value=value, literal_type=\"NUMBER\")\r\n+        elif hasattr(ctx, 'STRING_SINGLE') and ctx.STRING_SINGLE():\r\n+            value = ctx.STRING_SINGLE().getText()\r\n+            return LiteralExpressionNode(value=value, literal_type=\"STRING_SINGLE\")\r\n+        elif hasattr(ctx, 'STRING_DOUBLE') and ctx.STRING_DOUBLE():\r\n+            value = ctx.STRING_DOUBLE().getText()\r\n+            return LiteralExpressionNode(value=value, literal_type=\"STRING_DOUBLE\")\r\n+        else:\r\n+            return LiteralExpressionNode(value=ctx.getText(), literal_type=\"KEYWORD\")\r\n+\r\n+    def build_column_reference(self, ctx):\r\n+        from Ast.expression_nodes import ColumnReferenceExpressionNode\r\n+        tableName = None\r\n+        columnName = None\r\n+        if hasattr(ctx, 'columnName') and ctx.columnName():\r\n+            if hasattr(ctx, 'tableName') and ctx.tableName():\r\n+                tableName = self.build_table_name(ctx.tableName())\r\n+            columnName = ctx.columnName().getText()\r\n+        else:\r\n+            columnName = ctx.getText()\r\n+        return ColumnReferenceExpressionNode(table_name=tableName, column_name=columnName)\r\n+\r\n+    def build_function_call(self, ctx):\r\n+        from Ast.expression_nodes import FunctionCallExpressionNode\r\n+        functionName = ctx.getChild(0).getText()\r\n+        expressionList = self.build_expression_list(ctx.expressionList()) if hasattr(\r\n+            ctx, 'expressionList') and ctx.expressionList() else None\r\n+        return FunctionCallExpressionNode(function_name=functionName, arguments=expressionList)\r\n+\r\n+    def build_expression_list(self, ctx):\r\n+        expressions = []\r\n+        for expression in ctx.expression():\r\n+            expr = self.build_expression(expression)\r\n+            if expr is not None:\r\n+                expressions.append(expr)\r\n+        return expressions\r\n+\r\n+    def build_case_expression(self, ctx):\r\n+        from Ast.expression_nodes import CaseExpressionNode\r\n+        whenClauseList = []\r\n+        if hasattr(ctx, 'whenClause'):\r\n+            for whenClause in ctx.whenClause():\r\n+                clause = self.build_when_clause(whenClause)\r\n+                if clause is not None:\r\n+                    whenClauseList.append(clause)\r\n+        elseClause = self.build_else_clause(ctx.elseClause()) if hasattr(\r\n+            ctx, 'elseClause') and ctx.elseClause() else None\r\n+        return CaseExpressionNode(\r\n+            keywordCase=\"CASE\",\r\n+            whenClauseList=whenClauseList,\r\n+            elseClause=elseClause,\r\n+            keywordEnd=\"END\"\r\n+        )\r\n+\r\n+    def build_when_clause(self, ctx):\r\n+        from Ast.expression_nodes import WhenClauseNode\r\n+        from .condition_builder import ConditionBuilder\r\n+        condition_builder = ConditionBuilder()\r\n+\r\n+        condition = condition_builder.build_condition(ctx.condition())\r\n+        expression = self.build_expression(ctx.expression())\r\n+        return WhenClauseNode(\r\n+            keywordWhen=\"WHEN\",\r\n+            condition=condition,\r\n+            keyword=\"THEN\",\r\n+            expression=expression\r\n+        )\r\n+\r\n+    def build_else_clause(self, ctx):\r\n+        from Ast.expression_nodes import ElseClauseNode\r\n+        expression = self.build_expression(ctx.expression())\r\n+        return ElseClauseNode(keywordElse=\"ELSE\", expression=expression)\r\n+\r\n+    def build_table_name(self, ctx):\r\n+        text = ctx.getText()\r\n+        if '.' in text:\r\n+            parts = text.split('.')\r\n+            schema = parts[0].strip('[]')\r\n+            name = parts[-1].strip('[]')\r\n+        else:\r\n+            schema = None\r\n+            name = text.strip('[]')\r\n+\r\n+        return TableNameNode(schema=schema, name=name)\r\n"
                },
                {
                    "date": 1769009934745,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,171 +5,12 @@\n \r\n     def build_expression(self, ctx):\r\n         from Ast.expression_nodes import ParenthesizedExpressionNode, BinaryExpressionNode, VariableExpressionNode, LiteralExpressionNode\r\n \r\n-        if hasattr(ctx, 'primary') and ctx.primary():\r\n-            return self.build_primary(ctx.primary())\r\n+        print(f\"DEBUG build_expression: ctx type = {type(ctx).__name__}, hasattr primary = {hasattr(ctx, 'primary')}\")\r\n \r\n-        if hasattr(ctx, 'literal') and ctx.literal():\r\n-            return self.build_literal(ctx.literal())\r\n-        elif hasattr(ctx, 'columnReference') and ctx.columnReference():\r\n-            return self.build_column_reference(ctx.columnReference())\r\n-        elif hasattr(ctx, 'functionCall') and ctx.functionCall():\r\n-            return self.build_function_call(ctx.functionCall())\r\n-        elif hasattr(ctx, 'caseExpression') and ctx.caseExpression():\r\n-            return self.build_case_expression(ctx.caseExpression())\r\n-        elif hasattr(ctx, 'LPAREN') and ctx.LPAREN() and hasattr(ctx, 'RPAREN') and ctx.RPAREN():\r\n-            expression = self.build_expression(ctx.expression(0))\r\n-            return ParenthesizedExpressionNode(expression=expression)\r\n-        elif hasattr(ctx, 'binaryOp') and ctx.binaryOp() and len(ctx.expression()) == 2:\r\n-            left = self.build_expression(ctx.expression(0))\r\n-            operator = ctx.binaryOp().getText()\r\n-            right = self.build_expression(ctx.expression(1))\r\n-            return BinaryExpressionNode(left=left, operator=operator, right=right)\r\n-        elif hasattr(ctx, 'OPERATOR') and ctx.OPERATOR() and len(ctx.expression()) == 2:\r\n-            left = self.build_expression(ctx.expression(0))\r\n-            operator = ctx.OPERATOR().getText()\r\n-            right = self.build_expression(ctx.expression(1))\r\n-            return BinaryExpressionNode(left=left, operator=operator, right=right)\r\n-        elif hasattr(ctx, 'VARIABLE') and ctx.VARIABLE():\r\n-            variableName = ctx.VARIABLE().getText()\r\n-            return VariableExpressionNode(variable_name=variableName)\r\n-        elif hasattr(ctx, 'STRING_SINGLE') and ctx.STRING_SINGLE():\r\n-            value = ctx.STRING_SINGLE().getText()\r\n-            return LiteralExpressionNode(value=value, literal_type=\"STRING_SINGLE\")\r\n-        elif hasattr(ctx, 'STRING_DOUBLE') and ctx.STRING_DOUBLE():\r\n-            value = ctx.STRING_DOUBLE().getText()\r\n-            return LiteralExpressionNode(value=value, literal_type=\"STRING_DOUBLE\")\r\n-\r\n-        # Fallback for unknown expression types\r\n-        from dataclasses import dataclass\r\n-\r\n-        @dataclass\r\n-        class UnknownExpressionNode:\r\n-            type: str\r\n-            text: str\r\n-        return UnknownExpressionNode(type=\"UnknownExpression\", text=ctx.getText()[:50])\r\n-\r\n-    def build_primary(self, ctx):\r\n-        from Ast.expression_nodes import LiteralExpressionNode, VariableExpressionNode\r\n-\r\n-        if hasattr(ctx, 'literal') and ctx.literal():\r\n-            return self.build_literal(ctx.literal())\r\n-        elif hasattr(ctx, 'columnReference') and ctx.columnReference():\r\n-            return self.build_column_reference(ctx.columnReference())\r\n-        elif hasattr(ctx, 'functionCall') and ctx.functionCall():\r\n-            return self.build_function_call(ctx.functionCall())\r\n-        elif hasattr(ctx, 'VARIABLE') and ctx.VARIABLE():\r\n-            return VariableExpressionNode(variable_name=ctx.VARIABLE().getText())\r\n-        elif hasattr(ctx, 'expression') and ctx.expression():\r\n-            return self.build_expression(ctx.expression())\r\n-        elif hasattr(ctx, 'OPERATOR') and ctx.OPERATOR() and ctx.primary():\r\n-            op = ctx.OPERATOR().getText()\r\n-            inner = self.build_primary(ctx.primary())\r\n-            if isinstance(inner, LiteralExpressionNode):\r\n-                inner.value = op + inner.value\r\n-                return inner\r\n-            return inner\r\n-\r\n-        return None\r\n-\r\n-    def build_literal(self, ctx):\r\n-        from Ast.expression_nodes import LiteralExpressionNode\r\n-        if hasattr(ctx, 'NUMBER') and ctx.NUMBER():\r\n-            value = ctx.NUMBER().getText()\r\n-            return LiteralExpressionNode(value=value, literal_type=\"NUMBER\")\r\n-        elif hasattr(ctx, 'STRING_SINGLE') and ctx.STRING_SINGLE():\r\n-            value = ctx.STRING_SINGLE().getText()\r\n-            return LiteralExpressionNode(value=value, literal_type=\"STRING_SINGLE\")\r\n-        elif hasattr(ctx, 'STRING_DOUBLE') and ctx.STRING_DOUBLE():\r\n-            value = ctx.STRING_DOUBLE().getText()\r\n-            return LiteralExpressionNode(value=value, literal_type=\"STRING_DOUBLE\")\r\n-        else:\r\n-            return LiteralExpressionNode(value=ctx.getText(), literal_type=\"KEYWORD\")\r\n-\r\n-    def build_column_reference(self, ctx):\r\n-        from Ast.expression_nodes import ColumnReferenceExpressionNode\r\n-        tableName = None\r\n-        columnName = None\r\n-        if hasattr(ctx, 'columnName') and ctx.columnName():\r\n-            if hasattr(ctx, 'tableName') and ctx.tableName():\r\n-                tableName = self.build_table_name(ctx.tableName())\r\n-            columnName = ctx.columnName().getText()\r\n-        else:\r\n-            columnName = ctx.getText()\r\n-        return ColumnReferenceExpressionNode(table_name=tableName, column_name=columnName)\r\n-\r\n-    def build_function_call(self, ctx):\r\n-        from Ast.expression_nodes import FunctionCallExpressionNode\r\n-        functionName = ctx.getChild(0).getText()\r\n-        expressionList = self.build_expression_list(ctx.expressionList()) if hasattr(\r\n-            ctx, 'expressionList') and ctx.expressionList() else None\r\n-        return FunctionCallExpressionNode(function_name=functionName, arguments=expressionList)\r\n-\r\n-    def build_expression_list(self, ctx):\r\n-        expressions = []\r\n-        for expression in ctx.expression():\r\n-            expr = self.build_expression(expression)\r\n-            if expr is not None:\r\n-                expressions.append(expr)\r\n-        return expressions\r\n-\r\n-    def build_case_expression(self, ctx):\r\n-        from Ast.expression_nodes import CaseExpressionNode\r\n-        whenClauseList = []\r\n-        if hasattr(ctx, 'whenClause'):\r\n-            for whenClause in ctx.whenClause():\r\n-                clause = self.build_when_clause(whenClause)\r\n-                if clause is not None:\r\n-                    whenClauseList.append(clause)\r\n-        elseClause = self.build_else_clause(ctx.elseClause()) if hasattr(\r\n-            ctx, 'elseClause') and ctx.elseClause() else None\r\n-        return CaseExpressionNode(\r\n-            keywordCase=\"CASE\",\r\n-            whenClauseList=whenClauseList,\r\n-            elseClause=elseClause,\r\n-            keywordEnd=\"END\"\r\n-        )\r\n-\r\n-    def build_when_clause(self, ctx):\r\n-        from Ast.expression_nodes import WhenClauseNode\r\n-        from .condition_builder import ConditionBuilder\r\n-        condition_builder = ConditionBuilder()\r\n-\r\n-        condition = condition_builder.build_condition(ctx.condition())\r\n-        expression = self.build_expression(ctx.expression())\r\n-        return WhenClauseNode(\r\n-            keywordWhen=\"WHEN\",\r\n-            condition=condition,\r\n-            keyword=\"THEN\",\r\n-            expression=expression\r\n-        )\r\n-\r\n-    def build_else_clause(self, ctx):\r\n-        from Ast.expression_nodes import ElseClauseNode\r\n-        expression = self.build_expression(ctx.expression())\r\n-        return ElseClauseNode(keywordElse=\"ELSE\", expression=expression)\r\n-\r\n-    def build_table_name(self, ctx):\r\n-        text = ctx.getText()\r\n-        if '.' in text:\r\n-            parts = text.split('.')\r\n-            schema = parts[0].strip('[]')\r\n-            name = parts[-1].strip('[]')\r\n-        else:\r\n-            schema = None\r\n-            name = text.strip('[]')\r\n-\r\n-        return TableNameNode(schema=schema, name=name)\r\n-from Ast.statement_nodes import TableNameNode\r\n-\r\n-\r\n-class ExpressionBuilder:\r\n-\r\n-    def build_expression(self, ctx):\r\n-        from Ast.expression_nodes import ParenthesizedExpressionNode, BinaryExpressionNode, VariableExpressionNode, LiteralExpressionNode\r\n-\r\n         if hasattr(ctx, 'primary') and ctx.primary():\r\n+            print(f\"DEBUG: has primary, calling build_primary\")\r\n             return self.build_primary(ctx.primary())\r\n \r\n         if hasattr(ctx, 'literal') and ctx.literal():\r\n             return self.build_literal(ctx.literal())\r\n@@ -201,9 +42,9 @@\n         elif hasattr(ctx, 'STRING_DOUBLE') and ctx.STRING_DOUBLE():\r\n             value = ctx.STRING_DOUBLE().getText()\r\n             return LiteralExpressionNode(value=value, literal_type=\"STRING_DOUBLE\")\r\n \r\n-        # Fallback for unknown expression types\r\n+        print(f\"DEBUG build_expression: returning UnknownExpression for {ctx.getText()[:50]}\")\r\n         from dataclasses import dataclass\r\n \r\n         @dataclass\r\n         class UnknownExpressionNode:\r\n@@ -224,9 +65,8 @@\n             return VariableExpressionNode(variable_name=ctx.VARIABLE().getText())\r\n         elif hasattr(ctx, 'expression') and ctx.expression():\r\n             return self.build_expression(ctx.expression())\r\n         elif hasattr(ctx, 'OPERATOR') and ctx.OPERATOR() and ctx.primary():\r\n-            # Unary operator like -1\r\n             op = ctx.OPERATOR().getText()\r\n             inner = self.build_primary(ctx.primary())\r\n             if isinstance(inner, LiteralExpressionNode):\r\n                 inner.value = op + inner.value\r\n"
                },
                {
                    "date": 1769009946333,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,9 +5,10 @@\n \r\n     def build_expression(self, ctx):\r\n         from Ast.expression_nodes import ParenthesizedExpressionNode, BinaryExpressionNode, VariableExpressionNode, LiteralExpressionNode\r\n \r\n-        print(f\"DEBUG build_expression: ctx type = {type(ctx).__name__}, hasattr primary = {hasattr(ctx, 'primary')}\")\r\n+        print(\r\n+            f\"DEBUG build_expression: ctx type = {type(ctx).__name__}, hasattr primary = {hasattr(ctx, 'primary')}\")\r\n \r\n         if hasattr(ctx, 'primary') and ctx.primary():\r\n             print(f\"DEBUG: has primary, calling build_primary\")\r\n             return self.build_primary(ctx.primary())\r\n@@ -42,9 +43,10 @@\n         elif hasattr(ctx, 'STRING_DOUBLE') and ctx.STRING_DOUBLE():\r\n             value = ctx.STRING_DOUBLE().getText()\r\n             return LiteralExpressionNode(value=value, literal_type=\"STRING_DOUBLE\")\r\n \r\n-        print(f\"DEBUG build_expression: returning UnknownExpression for {ctx.getText()[:50]}\")\r\n+        print(\r\n+            f\"DEBUG build_expression: returning UnknownExpression for {ctx.getText()[:50]}\")\r\n         from dataclasses import dataclass\r\n \r\n         @dataclass\r\n         class UnknownExpressionNode:\r\n@@ -54,26 +56,36 @@\n \r\n     def build_primary(self, ctx):\r\n         from Ast.expression_nodes import LiteralExpressionNode, VariableExpressionNode\r\n \r\n+        print(f\"DEBUG build_primary: ctx type = {type(ctx).__name__}\")\r\n+        print(f\"DEBUG build_primary: hasattr literal={hasattr(ctx, 'literal')}, columnRef={hasattr(ctx, 'columnReference')}, funcCall={hasattr(ctx, 'functionCall')}, VARIABLE={hasattr(ctx, 'VARIABLE')}, expr={hasattr(ctx, 'expression')}\")\r\n+\r\n         if hasattr(ctx, 'literal') and ctx.literal():\r\n+            print(f\"DEBUG: has literal\")\r\n             return self.build_literal(ctx.literal())\r\n         elif hasattr(ctx, 'columnReference') and ctx.columnReference():\r\n+            print(f\"DEBUG: has columnReference\")\r\n             return self.build_column_reference(ctx.columnReference())\r\n         elif hasattr(ctx, 'functionCall') and ctx.functionCall():\r\n+            print(f\"DEBUG: has functionCall\")\r\n             return self.build_function_call(ctx.functionCall())\r\n         elif hasattr(ctx, 'VARIABLE') and ctx.VARIABLE():\r\n+            print(f\"DEBUG: has VARIABLE\")\r\n             return VariableExpressionNode(variable_name=ctx.VARIABLE().getText())\r\n         elif hasattr(ctx, 'expression') and ctx.expression():\r\n+            print(f\"DEBUG: has expression\")\r\n             return self.build_expression(ctx.expression())\r\n         elif hasattr(ctx, 'OPERATOR') and ctx.OPERATOR() and ctx.primary():\r\n+            print(f\"DEBUG: has OPERATOR and primary\")\r\n             op = ctx.OPERATOR().getText()\r\n             inner = self.build_primary(ctx.primary())\r\n             if isinstance(inner, LiteralExpressionNode):\r\n                 inner.value = op + inner.value\r\n                 return inner\r\n             return inner\r\n \r\n+        print(f\"DEBUG build_primary: returning None\")\r\n         return None\r\n \r\n     def build_literal(self, ctx):\r\n         from Ast.expression_nodes import LiteralExpressionNode\r\n"
                },
                {
                    "date": 1769009985581,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,10 +9,18 @@\n         print(\r\n             f\"DEBUG build_expression: ctx type = {type(ctx).__name__}, hasattr primary = {hasattr(ctx, 'primary')}\")\r\n \r\n         if hasattr(ctx, 'primary') and ctx.primary():\r\n-            print(f\"DEBUG: has primary, calling build_primary\")\r\n-            return self.build_primary(ctx.primary())\r\n+            primary = ctx.primary()\r\n+            # Handle the case where primary() returns a list\r\n+            if isinstance(primary, list):\r\n+                if len(primary) > 0:\r\n+                    primary = primary[0]\r\n+                else:\r\n+                    primary = None\r\n+            if primary:\r\n+                print(f\"DEBUG: has primary, calling build_primary\")\r\n+                return self.build_primary(primary)\r\n \r\n         if hasattr(ctx, 'literal') and ctx.literal():\r\n             return self.build_literal(ctx.literal())\r\n         elif hasattr(ctx, 'columnReference') and ctx.columnReference():\r\n@@ -57,9 +65,10 @@\n     def build_primary(self, ctx):\r\n         from Ast.expression_nodes import LiteralExpressionNode, VariableExpressionNode\r\n \r\n         print(f\"DEBUG build_primary: ctx type = {type(ctx).__name__}\")\r\n-        print(f\"DEBUG build_primary: hasattr literal={hasattr(ctx, 'literal')}, columnRef={hasattr(ctx, 'columnReference')}, funcCall={hasattr(ctx, 'functionCall')}, VARIABLE={hasattr(ctx, 'VARIABLE')}, expr={hasattr(ctx, 'expression')}\")\r\n+        print(\r\n+            f\"DEBUG build_primary: hasattr literal={hasattr(ctx, 'literal')}, columnRef={hasattr(ctx, 'columnReference')}, funcCall={hasattr(ctx, 'functionCall')}, VARIABLE={hasattr(ctx, 'VARIABLE')}, expr={hasattr(ctx, 'expression')}\")\r\n \r\n         if hasattr(ctx, 'literal') and ctx.literal():\r\n             print(f\"DEBUG: has literal\")\r\n             return self.build_literal(ctx.literal())\r\n"
                },
                {
                    "date": 1769010035676,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -69,22 +69,38 @@\n         print(\r\n             f\"DEBUG build_primary: hasattr literal={hasattr(ctx, 'literal')}, columnRef={hasattr(ctx, 'columnReference')}, funcCall={hasattr(ctx, 'functionCall')}, VARIABLE={hasattr(ctx, 'VARIABLE')}, expr={hasattr(ctx, 'expression')}\")\r\n \r\n         if hasattr(ctx, 'literal') and ctx.literal():\r\n-            print(f\"DEBUG: has literal\")\r\n-            return self.build_literal(ctx.literal())\r\n+            lit = ctx.literal()\r\n+            print(f\"DEBUG: has literal, lit type = {type(lit)}\")\r\n+            if isinstance(lit, list) and len(lit) > 0:\r\n+                return self.build_literal(lit[0])\r\n+            elif not isinstance(lit, list):\r\n+                return self.build_literal(lit)\r\n         elif hasattr(ctx, 'columnReference') and ctx.columnReference():\r\n             print(f\"DEBUG: has columnReference\")\r\n-            return self.build_column_reference(ctx.columnReference())\r\n+            colref = ctx.columnReference()\r\n+            if isinstance(colref, list) and len(colref) > 0:\r\n+                return self.build_column_reference(colref[0])\r\n+            elif not isinstance(colref, list):\r\n+                return self.build_column_reference(colref)\r\n         elif hasattr(ctx, 'functionCall') and ctx.functionCall():\r\n             print(f\"DEBUG: has functionCall\")\r\n-            return self.build_function_call(ctx.functionCall())\r\n+            func = ctx.functionCall()\r\n+            if isinstance(func, list) and len(func) > 0:\r\n+                return self.build_function_call(func[0])\r\n+            elif not isinstance(func, list):\r\n+                return self.build_function_call(func)\r\n         elif hasattr(ctx, 'VARIABLE') and ctx.VARIABLE():\r\n             print(f\"DEBUG: has VARIABLE\")\r\n             return VariableExpressionNode(variable_name=ctx.VARIABLE().getText())\r\n         elif hasattr(ctx, 'expression') and ctx.expression():\r\n             print(f\"DEBUG: has expression\")\r\n-            return self.build_expression(ctx.expression())\r\n+            expr = ctx.expression()\r\n+            if isinstance(expr, list) and len(expr) > 0:\r\n+                return self.build_expression(expr[0])\r\n+            elif not isinstance(expr, list):\r\n+                return self.build_expression(expr)\r\n         elif hasattr(ctx, 'OPERATOR') and ctx.OPERATOR() and ctx.primary():\r\n             print(f\"DEBUG: has OPERATOR and primary\")\r\n             op = ctx.OPERATOR().getText()\r\n             inner = self.build_primary(ctx.primary())\r\n"
                },
                {
                    "date": 1769010052671,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -62,45 +62,70 @@\n             text: str\r\n         return UnknownExpressionNode(type=\"UnknownExpression\", text=ctx.getText()[:50])\r\n \r\n     def build_primary(self, ctx):\r\n-        from Ast.expression_nodes import LiteralExpressionNode, VariableExpressionNode\r\n+        from Ast.expression_nodes import LiteralExpressionNode, VariableExpressionNode, ColumnReferenceExpressionNode\r\n \r\n         print(f\"DEBUG build_primary: ctx type = {type(ctx).__name__}\")\r\n-        print(\r\n-            f\"DEBUG build_primary: hasattr literal={hasattr(ctx, 'literal')}, columnRef={hasattr(ctx, 'columnReference')}, funcCall={hasattr(ctx, 'functionCall')}, VARIABLE={hasattr(ctx, 'VARIABLE')}, expr={hasattr(ctx, 'expression')}\")\r\n \r\n-        if hasattr(ctx, 'literal') and ctx.literal():\r\n+        # Try literal first\r\n+        if hasattr(ctx, 'literal'):\r\n             lit = ctx.literal()\r\n-            print(f\"DEBUG: has literal, lit type = {type(lit)}\")\r\n-            if isinstance(lit, list) and len(lit) > 0:\r\n-                return self.build_literal(lit[0])\r\n-            elif not isinstance(lit, list):\r\n-                return self.build_literal(lit)\r\n-        elif hasattr(ctx, 'columnReference') and ctx.columnReference():\r\n+            print(f\"DEBUG: ctx.literal() = {lit}, type = {type(lit)}\")\r\n+            if lit:\r\n+                if isinstance(lit, list) and len(lit) > 0:\r\n+                    return self.build_literal(lit[0])\r\n+                elif not isinstance(lit, list):\r\n+                    return self.build_literal(lit)\r\n+        \r\n+        # Try identifier (which creates a column reference)\r\n+        if hasattr(ctx, 'identifier'):\r\n+            ident = ctx.identifier()\r\n+            print(f\"DEBUG: ctx.identifier() = {ident}, type = {type(ident)}\")\r\n+            if ident:\r\n+                if isinstance(ident, list) and len(ident) > 0:\r\n+                    ident_text = ident[0].getText()\r\n+                elif not isinstance(ident, list):\r\n+                    ident_text = ident.getText()\r\n+                else:\r\n+                    ident_text = None\r\n+                \r\n+                if ident_text:\r\n+                    return ColumnReferenceExpressionNode(table_name=None, column_name=ident_text)\r\n+        \r\n+        # Try columnReference\r\n+        if hasattr(ctx, 'columnReference') and ctx.columnReference():\r\n             print(f\"DEBUG: has columnReference\")\r\n             colref = ctx.columnReference()\r\n             if isinstance(colref, list) and len(colref) > 0:\r\n                 return self.build_column_reference(colref[0])\r\n             elif not isinstance(colref, list):\r\n                 return self.build_column_reference(colref)\r\n+        \r\n+        # Try functionCall\r\n         elif hasattr(ctx, 'functionCall') and ctx.functionCall():\r\n             print(f\"DEBUG: has functionCall\")\r\n             func = ctx.functionCall()\r\n             if isinstance(func, list) and len(func) > 0:\r\n                 return self.build_function_call(func[0])\r\n             elif not isinstance(func, list):\r\n                 return self.build_function_call(func)\r\n+        \r\n+        # Try VARIABLE\r\n         elif hasattr(ctx, 'VARIABLE') and ctx.VARIABLE():\r\n             print(f\"DEBUG: has VARIABLE\")\r\n             return VariableExpressionNode(variable_name=ctx.VARIABLE().getText())\r\n+        \r\n+        # Try nested expression\r\n         elif hasattr(ctx, 'expression') and ctx.expression():\r\n             print(f\"DEBUG: has expression\")\r\n             expr = ctx.expression()\r\n             if isinstance(expr, list) and len(expr) > 0:\r\n                 return self.build_expression(expr[0])\r\n             elif not isinstance(expr, list):\r\n                 return self.build_expression(expr)\r\n+        \r\n+        # Try OPERATOR\r\n         elif hasattr(ctx, 'OPERATOR') and ctx.OPERATOR() and ctx.primary():\r\n             print(f\"DEBUG: has OPERATOR and primary\")\r\n             op = ctx.OPERATOR().getText()\r\n             inner = self.build_primary(ctx.primary())\r\n"
                },
                {
                    "date": 1769010071029,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -69,62 +69,55 @@\n \r\n         # Try literal first\r\n         if hasattr(ctx, 'literal'):\r\n             lit = ctx.literal()\r\n-            print(f\"DEBUG: ctx.literal() = {lit}, type = {type(lit)}\")\r\n+            print(f\"DEBUG: ctx.literal() = {lit}\")\r\n             if lit:\r\n                 if isinstance(lit, list) and len(lit) > 0:\r\n                     return self.build_literal(lit[0])\r\n                 elif not isinstance(lit, list):\r\n                     return self.build_literal(lit)\r\n         \r\n         # Try identifier (which creates a column reference)\r\n         if hasattr(ctx, 'identifier'):\r\n-            ident = ctx.identifier()\r\n-            print(f\"DEBUG: ctx.identifier() = {ident}, type = {type(ident)}\")\r\n-            if ident:\r\n-                if isinstance(ident, list) and len(ident) > 0:\r\n-                    ident_text = ident[0].getText()\r\n-                elif not isinstance(ident, list):\r\n-                    ident_text = ident.getText()\r\n+            ident_ctx = ctx.identifier()\r\n+            print(f\"DEBUG: ctx.identifier() = {ident_ctx}, has getText = {hasattr(ident_ctx, 'getText')}\")\r\n+            if ident_ctx:\r\n+                if isinstance(ident_ctx, list) and len(ident_ctx) > 0:\r\n+                    ident_text = ident_ctx[0].getText()\r\n+                elif not isinstance(ident_ctx, list) and hasattr(ident_ctx, 'getText'):\r\n+                    ident_text = ident_ctx.getText()\r\n                 else:\r\n                     ident_text = None\r\n                 \r\n-                if ident_text:\r\n-                    return ColumnReferenceExpressionNode(table_name=None, column_name=ident_text)\r\n-        \r\n-        # Try columnReference\r\n-        if hasattr(ctx, 'columnReference') and ctx.columnReference():\r\n-            print(f\"DEBUG: has columnReference\")\r\n-            colref = ctx.columnReference()\r\n-            if isinstance(colref, list) and len(colref) > 0:\r\n+                print(f\"DEBUG: ident_text = {ident_text}\")\r\n                 return self.build_column_reference(colref[0])\r\n             elif not isinstance(colref, list):\r\n                 return self.build_column_reference(colref)\r\n-        \r\n+\r\n         # Try functionCall\r\n         elif hasattr(ctx, 'functionCall') and ctx.functionCall():\r\n             print(f\"DEBUG: has functionCall\")\r\n             func = ctx.functionCall()\r\n             if isinstance(func, list) and len(func) > 0:\r\n                 return self.build_function_call(func[0])\r\n             elif not isinstance(func, list):\r\n                 return self.build_function_call(func)\r\n-        \r\n+\r\n         # Try VARIABLE\r\n         elif hasattr(ctx, 'VARIABLE') and ctx.VARIABLE():\r\n             print(f\"DEBUG: has VARIABLE\")\r\n             return VariableExpressionNode(variable_name=ctx.VARIABLE().getText())\r\n-        \r\n+\r\n         # Try nested expression\r\n         elif hasattr(ctx, 'expression') and ctx.expression():\r\n             print(f\"DEBUG: has expression\")\r\n             expr = ctx.expression()\r\n             if isinstance(expr, list) and len(expr) > 0:\r\n                 return self.build_expression(expr[0])\r\n             elif not isinstance(expr, list):\r\n                 return self.build_expression(expr)\r\n-        \r\n+\r\n         # Try OPERATOR\r\n         elif hasattr(ctx, 'OPERATOR') and ctx.OPERATOR() and ctx.primary():\r\n             print(f\"DEBUG: has OPERATOR and primary\")\r\n             op = ctx.OPERATOR().getText()\r\n"
                },
                {
                    "date": 1769010119762,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -64,71 +64,66 @@\n \r\n     def build_primary(self, ctx):\r\n         from Ast.expression_nodes import LiteralExpressionNode, VariableExpressionNode, ColumnReferenceExpressionNode\r\n \r\n-        print(f\"DEBUG build_primary: ctx type = {type(ctx).__name__}\")\r\n-\r\n         # Try literal first\r\n-        if hasattr(ctx, 'literal'):\r\n+        if hasattr(ctx, 'literal') and ctx.literal():\r\n             lit = ctx.literal()\r\n-            print(f\"DEBUG: ctx.literal() = {lit}\")\r\n-            if lit:\r\n-                if isinstance(lit, list) and len(lit) > 0:\r\n-                    return self.build_literal(lit[0])\r\n-                elif not isinstance(lit, list):\r\n-                    return self.build_literal(lit)\r\n+            if isinstance(lit, list) and len(lit) > 0:\r\n+                return self.build_literal(lit[0])\r\n+            else:\r\n+                return self.build_literal(lit)\r\n         \r\n         # Try identifier (which creates a column reference)\r\n-        if hasattr(ctx, 'identifier'):\r\n+        if hasattr(ctx, 'identifier') and ctx.identifier():\r\n             ident_ctx = ctx.identifier()\r\n-            print(f\"DEBUG: ctx.identifier() = {ident_ctx}, has getText = {hasattr(ident_ctx, 'getText')}\")\r\n-            if ident_ctx:\r\n-                if isinstance(ident_ctx, list) and len(ident_ctx) > 0:\r\n-                    ident_text = ident_ctx[0].getText()\r\n-                elif not isinstance(ident_ctx, list) and hasattr(ident_ctx, 'getText'):\r\n-                    ident_text = ident_ctx.getText()\r\n-                else:\r\n-                    ident_text = None\r\n-                \r\n-                print(f\"DEBUG: ident_text = {ident_text}\")\r\n+            if isinstance(ident_ctx, list) and len(ident_ctx) > 0:\r\n+                ident_text = ident_ctx[0].getText()\r\n+            elif not isinstance(ident_ctx, list):\r\n+                ident_text = ident_ctx.getText()\r\n+            else:\r\n+                ident_text = None\r\n+            \r\n+            if ident_text:\r\n+                return ColumnReferenceExpressionNode(table_name=None, column_name=ident_text)\r\n+        \r\n+        # Try columnReference\r\n+        if hasattr(ctx, 'columnReference') and ctx.columnReference():\r\n+            colref = ctx.columnReference()\r\n+            if isinstance(colref, list) and len(colref) > 0:\r\n                 return self.build_column_reference(colref[0])\r\n-            elif not isinstance(colref, list):\r\n+            else:\r\n                 return self.build_column_reference(colref)\r\n-\r\n+        \r\n         # Try functionCall\r\n-        elif hasattr(ctx, 'functionCall') and ctx.functionCall():\r\n-            print(f\"DEBUG: has functionCall\")\r\n+        if hasattr(ctx, 'functionCall') and ctx.functionCall():\r\n             func = ctx.functionCall()\r\n             if isinstance(func, list) and len(func) > 0:\r\n                 return self.build_function_call(func[0])\r\n-            elif not isinstance(func, list):\r\n+            else:\r\n                 return self.build_function_call(func)\r\n-\r\n+        \r\n         # Try VARIABLE\r\n-        elif hasattr(ctx, 'VARIABLE') and ctx.VARIABLE():\r\n-            print(f\"DEBUG: has VARIABLE\")\r\n+        if hasattr(ctx, 'VARIABLE') and ctx.VARIABLE():\r\n             return VariableExpressionNode(variable_name=ctx.VARIABLE().getText())\r\n-\r\n+        \r\n         # Try nested expression\r\n-        elif hasattr(ctx, 'expression') and ctx.expression():\r\n-            print(f\"DEBUG: has expression\")\r\n+        if hasattr(ctx, 'expression') and ctx.expression():\r\n             expr = ctx.expression()\r\n             if isinstance(expr, list) and len(expr) > 0:\r\n                 return self.build_expression(expr[0])\r\n-            elif not isinstance(expr, list):\r\n+            else:\r\n                 return self.build_expression(expr)\r\n-\r\n+        \r\n         # Try OPERATOR\r\n-        elif hasattr(ctx, 'OPERATOR') and ctx.OPERATOR() and ctx.primary():\r\n-            print(f\"DEBUG: has OPERATOR and primary\")\r\n+        if hasattr(ctx, 'OPERATOR') and ctx.OPERATOR() and ctx.primary():\r\n             op = ctx.OPERATOR().getText()\r\n             inner = self.build_primary(ctx.primary())\r\n             if isinstance(inner, LiteralExpressionNode):\r\n                 inner.value = op + inner.value\r\n                 return inner\r\n             return inner\r\n \r\n-        print(f\"DEBUG build_primary: returning None\")\r\n         return None\r\n \r\n     def build_literal(self, ctx):\r\n         from Ast.expression_nodes import LiteralExpressionNode\r\n"
                },
                {
                    "date": 1769012027358,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,11 +5,8 @@\n \r\n     def build_expression(self, ctx):\r\n         from Ast.expression_nodes import ParenthesizedExpressionNode, BinaryExpressionNode, VariableExpressionNode, LiteralExpressionNode\r\n \r\n-        print(\r\n-            f\"DEBUG build_expression: ctx type = {type(ctx).__name__}, hasattr primary = {hasattr(ctx, 'primary')}\")\r\n-\r\n         if hasattr(ctx, 'primary') and ctx.primary():\r\n             primary = ctx.primary()\r\n             # Handle the case where primary() returns a list\r\n             if isinstance(primary, list):\r\n@@ -17,9 +14,8 @@\n                     primary = primary[0]\r\n                 else:\r\n                     primary = None\r\n             if primary:\r\n-                print(f\"DEBUG: has primary, calling build_primary\")\r\n                 return self.build_primary(primary)\r\n \r\n         if hasattr(ctx, 'literal') and ctx.literal():\r\n             return self.build_literal(ctx.literal())\r\n@@ -31,18 +27,22 @@\n             return self.build_case_expression(ctx.caseExpression())\r\n         elif hasattr(ctx, 'LPAREN') and ctx.LPAREN() and hasattr(ctx, 'RPAREN') and ctx.RPAREN():\r\n             expression = self.build_expression(ctx.expression(0))\r\n             return ParenthesizedExpressionNode(expression=expression)\r\n-        elif hasattr(ctx, 'binaryOp') and ctx.binaryOp() and len(ctx.expression()) == 2:\r\n-            left = self.build_expression(ctx.expression(0))\r\n-            operator = ctx.binaryOp().getText()\r\n-            right = self.build_expression(ctx.expression(1))\r\n-            return BinaryExpressionNode(left=left, operator=operator, right=right)\r\n-        elif hasattr(ctx, 'OPERATOR') and ctx.OPERATOR() and len(ctx.expression()) == 2:\r\n-            left = self.build_expression(ctx.expression(0))\r\n-            operator = ctx.OPERATOR().getText()\r\n-            right = self.build_expression(ctx.expression(1))\r\n-            return BinaryExpressionNode(left=left, operator=operator, right=right)\r\n+        elif hasattr(ctx, 'binaryOp') and ctx.binaryOp():\r\n+            expr_list = ctx.expression()\r\n+            if expr_list and len(expr_list) == 2:\r\n+                left = self.build_expression(expr_list[0])\r\n+                operator = ctx.binaryOp().getText()\r\n+                right = self.build_expression(expr_list[1])\r\n+                return BinaryExpressionNode(left=left, operator=operator, right=right)\r\n+        elif hasattr(ctx, 'OPERATOR') and ctx.OPERATOR():\r\n+            expr_list = ctx.expression()\r\n+            if expr_list and len(expr_list) == 2:\r\n+                left = self.build_expression(expr_list[0])\r\n+                operator = ctx.OPERATOR().getText()\r\n+                right = self.build_expression(expr_list[1])\r\n+                return BinaryExpressionNode(left=left, operator=operator, right=right)\r\n         elif hasattr(ctx, 'VARIABLE') and ctx.VARIABLE():\r\n             variableName = ctx.VARIABLE().getText()\r\n             return VariableExpressionNode(variable_name=variableName)\r\n         elif hasattr(ctx, 'STRING_SINGLE') and ctx.STRING_SINGLE():\r\n@@ -51,10 +51,8 @@\n         elif hasattr(ctx, 'STRING_DOUBLE') and ctx.STRING_DOUBLE():\r\n             value = ctx.STRING_DOUBLE().getText()\r\n             return LiteralExpressionNode(value=value, literal_type=\"STRING_DOUBLE\")\r\n \r\n-        print(\r\n-            f\"DEBUG build_expression: returning UnknownExpression for {ctx.getText()[:50]}\")\r\n         from dataclasses import dataclass\r\n \r\n         @dataclass\r\n         class UnknownExpressionNode:\r\n"
                },
                {
                    "date": 1769013766191,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,16 +51,13 @@\n         elif hasattr(ctx, 'STRING_DOUBLE') and ctx.STRING_DOUBLE():\r\n             value = ctx.STRING_DOUBLE().getText()\r\n             return LiteralExpressionNode(value=value, literal_type=\"STRING_DOUBLE\")\r\n \r\n-        from dataclasses import dataclass\r\n+        # DEFAULT: Return a literal node instead of UnknownExpressionNode\r\n+        # This ensures no null/unknown expressions in the AST\r\n+        text = ctx.getText() if hasattr(ctx, 'getText') else str(ctx)\r\n+        return LiteralExpressionNode(value=text, literal_type=\"EXPRESSION\")\r\n \r\n-        @dataclass\r\n-        class UnknownExpressionNode:\r\n-            type: str\r\n-            text: str\r\n-        return UnknownExpressionNode(type=\"UnknownExpression\", text=ctx.getText()[:50])\r\n-\r\n     def build_primary(self, ctx):\r\n         from Ast.expression_nodes import LiteralExpressionNode, VariableExpressionNode, ColumnReferenceExpressionNode\r\n \r\n         # Try literal first\r\n@@ -69,9 +66,9 @@\n             if isinstance(lit, list) and len(lit) > 0:\r\n                 return self.build_literal(lit[0])\r\n             else:\r\n                 return self.build_literal(lit)\r\n-        \r\n+\r\n         # Try identifier (which creates a column reference)\r\n         if hasattr(ctx, 'identifier') and ctx.identifier():\r\n             ident_ctx = ctx.identifier()\r\n             if isinstance(ident_ctx, list) and len(ident_ctx) > 0:\r\n@@ -79,40 +76,40 @@\n             elif not isinstance(ident_ctx, list):\r\n                 ident_text = ident_ctx.getText()\r\n             else:\r\n                 ident_text = None\r\n-            \r\n+\r\n             if ident_text:\r\n                 return ColumnReferenceExpressionNode(table_name=None, column_name=ident_text)\r\n-        \r\n+\r\n         # Try columnReference\r\n         if hasattr(ctx, 'columnReference') and ctx.columnReference():\r\n             colref = ctx.columnReference()\r\n             if isinstance(colref, list) and len(colref) > 0:\r\n                 return self.build_column_reference(colref[0])\r\n             else:\r\n                 return self.build_column_reference(colref)\r\n-        \r\n+\r\n         # Try functionCall\r\n         if hasattr(ctx, 'functionCall') and ctx.functionCall():\r\n             func = ctx.functionCall()\r\n             if isinstance(func, list) and len(func) > 0:\r\n                 return self.build_function_call(func[0])\r\n             else:\r\n                 return self.build_function_call(func)\r\n-        \r\n+\r\n         # Try VARIABLE\r\n         if hasattr(ctx, 'VARIABLE') and ctx.VARIABLE():\r\n             return VariableExpressionNode(variable_name=ctx.VARIABLE().getText())\r\n-        \r\n+\r\n         # Try nested expression\r\n         if hasattr(ctx, 'expression') and ctx.expression():\r\n             expr = ctx.expression()\r\n             if isinstance(expr, list) and len(expr) > 0:\r\n                 return self.build_expression(expr[0])\r\n             else:\r\n                 return self.build_expression(expr)\r\n-        \r\n+\r\n         # Try OPERATOR\r\n         if hasattr(ctx, 'OPERATOR') and ctx.OPERATOR() and ctx.primary():\r\n             op = ctx.OPERATOR().getText()\r\n             inner = self.build_primary(ctx.primary())\r\n"
                },
                {
                    "date": 1769014298898,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,13 +51,16 @@\n         elif hasattr(ctx, 'STRING_DOUBLE') and ctx.STRING_DOUBLE():\r\n             value = ctx.STRING_DOUBLE().getText()\r\n             return LiteralExpressionNode(value=value, literal_type=\"STRING_DOUBLE\")\r\n \r\n-        # DEFAULT: Return a literal node instead of UnknownExpressionNode\r\n-        # This ensures no null/unknown expressions in the AST\r\n-        text = ctx.getText() if hasattr(ctx, 'getText') else str(ctx)\r\n-        return LiteralExpressionNode(value=text, literal_type=\"EXPRESSION\")\r\n+        from dataclasses import dataclass\r\n \r\n+        @dataclass\r\n+        class UnknownExpressionNode:\r\n+            type: str\r\n+            text: str\r\n+        return UnknownExpressionNode(type=\"UnknownExpression\", text=ctx.getText()[:50])\r\n+\r\n     def build_primary(self, ctx):\r\n         from Ast.expression_nodes import LiteralExpressionNode, VariableExpressionNode, ColumnReferenceExpressionNode\r\n \r\n         # Try literal first\r\n"
                },
                {
                    "date": 1769016183810,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -62,8 +62,15 @@\n \r\n     def build_primary(self, ctx):\r\n         from Ast.expression_nodes import LiteralExpressionNode, VariableExpressionNode, ColumnReferenceExpressionNode\r\n \r\n+        # Check for subquery (SELECT statement in parentheses)\r\n+        if hasattr(ctx, 'selectStatement') and ctx.selectStatement():\r\n+            # Import here to avoid circular dependency\r\n+            from builders.statement_builder import StatementBuilder\r\n+            stmt_builder = StatementBuilder()\r\n+            return stmt_builder.build_select(ctx.selectStatement())\r\n+\r\n         # Try literal first\r\n         if hasattr(ctx, 'literal') and ctx.literal():\r\n             lit = ctx.literal()\r\n             if isinstance(lit, list) and len(lit) > 0:\r\n@@ -209,5 +216,5 @@\n         else:\r\n             schema = None\r\n             name = text.strip('[]')\r\n \r\n-        return TableNameNode(schema=schema, name=name)\r\n+        return TableNameNode(schema=schema, name=name)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1769016281975,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -216,5 +216,5 @@\n         else:\r\n             schema = None\r\n             name = text.strip('[]')\r\n \r\n-        return TableNameNode(schema=schema, name=name)\n\\ No newline at end of file\n+        return TableNameNode(schema=schema, name=name)\r\n"
                },
                {
                    "date": 1769016288453,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -118,9 +118,8 @@\n                 return self.build_expression(expr[0])\r\n             else:\r\n                 return self.build_expression(expr)\r\n \r\n-        # Try OPERATOR\r\n         if hasattr(ctx, 'OPERATOR') and ctx.OPERATOR() and ctx.primary():\r\n             op = ctx.OPERATOR().getText()\r\n             inner = self.build_primary(ctx.primary())\r\n             if isinstance(inner, LiteralExpressionNode):\r\n"
                },
                {
                    "date": 1769016293993,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -98,9 +98,8 @@\n                 return self.build_column_reference(colref[0])\r\n             else:\r\n                 return self.build_column_reference(colref)\r\n \r\n-        # Try functionCall\r\n         if hasattr(ctx, 'functionCall') and ctx.functionCall():\r\n             func = ctx.functionCall()\r\n             if isinstance(func, list) and len(func) > 0:\r\n                 return self.build_function_call(func[0])\r\n"
                },
                {
                    "date": 1769016300989,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -69,9 +69,8 @@\n             from builders.statement_builder import StatementBuilder\r\n             stmt_builder = StatementBuilder()\r\n             return stmt_builder.build_select(ctx.selectStatement())\r\n \r\n-        # Try literal first\r\n         if hasattr(ctx, 'literal') and ctx.literal():\r\n             lit = ctx.literal()\r\n             if isinstance(lit, list) and len(lit) > 0:\r\n                 return self.build_literal(lit[0])\r\n"
                },
                {
                    "date": 1769016310161,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,8 @@\n         from Ast.expression_nodes import ParenthesizedExpressionNode, BinaryExpressionNode, VariableExpressionNode, LiteralExpressionNode\r\n \r\n         if hasattr(ctx, 'primary') and ctx.primary():\r\n             primary = ctx.primary()\r\n-            # Handle the case where primary() returns a list\r\n             if isinstance(primary, list):\r\n                 if len(primary) > 0:\r\n                     primary = primary[0]\r\n                 else:\r\n"
                }
            ],
            "date": 1768866022251,
            "name": "Commit-0",
            "content": "from Ast.statement_nodes import TableNameNode\n\n\nclass ExpressionBuilder:\n\n    def build_expression(self, ctx):\n        \"\"\"Build an expression node from context\"\"\"\n        from Ast.expression_nodes import ParenthesizedExpressionNode, BinaryExpressionNode, VariableExpressionNode, LiteralExpressionNode\n        \n        if hasattr(ctx, 'primary') and ctx.primary():\n            return self.build_primary(ctx.primary())\n        \n        if hasattr(ctx, 'literal') and ctx.literal():\n            return self.build_literal(ctx.literal())\n        elif hasattr(ctx, 'columnReference') and ctx.columnReference():\n            return self.build_column_reference(ctx.columnReference())\n        elif hasattr(ctx, 'functionCall') and ctx.functionCall():\n            return self.build_function_call(ctx.functionCall())\n        elif hasattr(ctx, 'caseExpression') and ctx.caseExpression():\n            return self.build_case_expression(ctx.caseExpression())\n        elif hasattr(ctx, 'LPAREN') and ctx.LPAREN() and hasattr(ctx, 'RPAREN') and ctx.RPAREN():\n            expression = self.build_expression(ctx.expression(0))\n            return ParenthesizedExpressionNode(expression=expression)\n        elif hasattr(ctx, 'binaryOp') and ctx.binaryOp() and len(ctx.expression()) == 2:\n            left = self.build_expression(ctx.expression(0))\n            operator = ctx.binaryOp().getText()\n            right = self.build_expression(ctx.expression(1))\n            return BinaryExpressionNode(left=left, operator=operator, right=right)\n        elif hasattr(ctx, 'OPERATOR') and ctx.OPERATOR() and len(ctx.expression()) == 2:\n            left = self.build_expression(ctx.expression(0))\n            operator = ctx.OPERATOR().getText()\n            right = self.build_expression(ctx.expression(1))\n            return BinaryExpressionNode(left=left, operator=operator, right=right)\n        elif hasattr(ctx, 'VARIABLE') and ctx.VARIABLE():\n            variableName = ctx.VARIABLE().getText()\n            return VariableExpressionNode(variable_name=variableName)\n        elif hasattr(ctx, 'STRING_SINGLE') and ctx.STRING_SINGLE():\n            value = ctx.STRING_SINGLE().getText()\n            return LiteralExpressionNode(value=value, literal_type=\"STRING_SINGLE\")\n        elif hasattr(ctx, 'STRING_DOUBLE') and ctx.STRING_DOUBLE():\n            value = ctx.STRING_DOUBLE().getText()\n            return LiteralExpressionNode(value=value, literal_type=\"STRING_DOUBLE\")\n        \n        # Fallback for unknown expression types\n        from dataclasses import dataclass\n        @dataclass\n        class UnknownExpressionNode:\n            type: str\n            text: str\n        return UnknownExpressionNode(type=\"UnknownExpression\", text=ctx.getText()[:50])\n\n    def build_primary(self, ctx):\n        \"\"\"Build primary expression\"\"\"\n        from Ast.expression_nodes import LiteralExpressionNode, VariableExpressionNode\n        \n        if hasattr(ctx, 'literal') and ctx.literal():\n            return self.build_literal(ctx.literal())\n        elif hasattr(ctx, 'columnReference') and ctx.columnReference():\n            return self.build_column_reference(ctx.columnReference())\n        elif hasattr(ctx, 'functionCall') and ctx.functionCall():\n            return self.build_function_call(ctx.functionCall())\n        elif hasattr(ctx, 'VARIABLE') and ctx.VARIABLE():\n            return VariableExpressionNode(variable_name=ctx.VARIABLE().getText())\n        elif hasattr(ctx, 'expression') and ctx.expression():\n            return self.build_expression(ctx.expression())\n        elif hasattr(ctx, 'OPERATOR') and ctx.OPERATOR() and ctx.primary():\n            # Unary operator like -1\n            op = ctx.OPERATOR().getText()\n            inner = self.build_primary(ctx.primary())\n            if isinstance(inner, LiteralExpressionNode):\n                inner.value = op + inner.value\n                return inner\n            return inner\n        \n        return None\n\n    def build_literal(self, ctx):\n        \"\"\"Build a literal expression node\"\"\"\n        from Ast.expression_nodes import LiteralExpressionNode\n        if hasattr(ctx, 'NUMBER') and ctx.NUMBER():\n            value = ctx.NUMBER().getText()\n            return LiteralExpressionNode(value=value, literal_type=\"NUMBER\")\n        elif hasattr(ctx, 'STRING_SINGLE') and ctx.STRING_SINGLE():\n            value = ctx.STRING_SINGLE().getText()\n            return LiteralExpressionNode(value=value, literal_type=\"STRING_SINGLE\")\n        elif hasattr(ctx, 'STRING_DOUBLE') and ctx.STRING_DOUBLE():\n            value = ctx.STRING_DOUBLE().getText()\n            return LiteralExpressionNode(value=value, literal_type=\"STRING_DOUBLE\")\n        else:\n            # Fallback to text (NULL, etc)\n            return LiteralExpressionNode(value=ctx.getText(), literal_type=\"KEYWORD\")\n\n    def build_column_reference(self, ctx):\n        \"\"\"Build a column reference node\"\"\"\n        from Ast.expression_nodes import ColumnReferenceExpressionNode\n        tableName = None\n        columnName = None\n        if hasattr(ctx, 'columnName') and ctx.columnName():\n            if hasattr(ctx, 'tableName') and ctx.tableName():\n                tableName = self.build_table_name(ctx.tableName())\n            columnName = ctx.columnName().getText()\n        else:\n            columnName = ctx.getText()\n        return ColumnReferenceExpressionNode(table_name=tableName, column_name=columnName)\n\n    def build_function_call(self, ctx):\n        \"\"\"Build a function call node\"\"\"\n        from Ast.expression_nodes import FunctionCallExpressionNode\n        functionName = ctx.getChild(0).getText()\n        expressionList = self.build_expression_list(ctx.expressionList()) if hasattr(ctx, 'expressionList') and ctx.expressionList() else None\n        return FunctionCallExpressionNode(function_name=functionName, arguments=expressionList)\n\n    def build_expression_list(self, ctx):\n        \"\"\"Build a list of expressions\"\"\"\n        expressions = []\n        for expression in ctx.expression():\n            expr = self.build_expression(expression)\n            if expr is not None:\n                expressions.append(expr)\n        return expressions\n\n    def build_case_expression(self, ctx):\n        \"\"\"Build a CASE expression node\"\"\"\n        from Ast.expression_nodes import CaseExpressionNode\n        whenClauseList = []\n        if hasattr(ctx, 'whenClause'):\n            for whenClause in ctx.whenClause():\n                clause = self.build_when_clause(whenClause)\n                if clause is not None:\n                    whenClauseList.append(clause)\n        elseClause = self.build_else_clause(ctx.elseClause()) if hasattr(ctx, 'elseClause') and ctx.elseClause() else None\n        return CaseExpressionNode(\n            keywordCase=\"CASE\",\n            whenClauseList=whenClauseList,\n            elseClause=elseClause,\n            keywordEnd=\"END\"\n        )\n\n    def build_when_clause(self, ctx):\n        \"\"\"Build a WHEN clause node\"\"\"\n        from Ast.expression_nodes import WhenClauseNode\n        from .condition_builder import ConditionBuilder\n        condition_builder = ConditionBuilder()\n\n        condition = condition_builder.build_condition(ctx.condition())\n        expression = self.build_expression(ctx.expression())\n        return WhenClauseNode(\n            keywordWhen=\"WHEN\",\n            condition=condition,\n            keyword=\"THEN\",\n            expression=expression\n        )\n\n    def build_else_clause(self, ctx):\n        \"\"\"Build an ELSE clause node\"\"\"\n        from Ast.expression_nodes import ElseClauseNode\n        expression = self.build_expression(ctx.expression())\n        return ElseClauseNode(keywordElse=\"ELSE\", expression=expression)\n\n    def build_table_name(self, ctx):\n        \"\"\"Build a table name node\"\"\"\n        text = ctx.getText()\n        if '.' in text:\n            parts = text.split('.')\n            schema = parts[0].strip('[]')\n            name = parts[-1].strip('[]')\n        else:\n            schema = None\n            name = text.strip('[]')\n\n        return TableNameNode(schema=schema, name=name)\n"
        }
    ]
}